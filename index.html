<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Clarence Yeung · Portfolio</title>
    <link rel="stylesheet" href="style.css" />
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.158/build/three.module.js",
          "three/examples/jsm/controls/OrbitControls.js": "https://cdn.jsdelivr.net/npm/three@0.158/examples/jsm/controls/OrbitControls.js",
          "three/examples/jsm/utils/BufferGeometryUtils.js": "https://cdn.jsdelivr.net/npm/three@0.158/examples/jsm/utils/BufferGeometryUtils.js"
        }
      }
    </script>
  </head>
  <body>
    <!-- Layout Wrapper -->
    <main class="page">
      <!-- Visual Placeholder Column -->
      <section class="visual-column">
        <div class="visual-container" role="presentation">
          <div class="visual-stage" id="globe-stage" aria-hidden="true"></div>
          <div
            class="visual-tooltip"
            id="globe-tooltip"
            role="status"
            aria-live="polite"
            hidden
          ></div>
        </div>
      </section>

      <!-- Content Column -->
      <section class="content-column">
        <header class="page-header">
          <div class="header-inner">
            <div class="hero-portrait" aria-hidden="true">
              <span>Portrait</span>
            </div>
            <h1>Clarence Yeung</h1>
          </div>
        </header>

        <!-- About Section -->
        <section class="content-section" id="about">
          <h2>About Me</h2>
          <nav aria-label="Primary links" class="about-links">
            <a href="https://www.linkedin.com" target="_blank" rel="noopener">LinkedIn</a>
            <span aria-hidden="true">·</span>
            <a href="https://scholar.google.com" target="_blank" rel="noopener"
              >Google Scholar</a
            >
            <span aria-hidden="true">·</span>
            <a href="https://github.com" target="_blank" rel="noopener">GitHub</a>
          </nav>
        </section>

        <!-- Projects Section -->
        <section class="content-section" id="projects">
          <h2>Projects</h2>
          <ul class="project-list">
            <li>
              <h3>Motion Atlas</h3>
              <p>
                A generative study that maps cycling telemetry into kinetic sculptures, pairing
                physics with visual storytelling.
              </p>
            </li>
            <li>
              <h3>Helix Studio</h3>
              <p>
                Interactive DNA narratives that invite visitors to manipulate molecular forms through
                touch and gesture.
              </p>
            </li>
            <li>
              <h3>Living Recipes</h3>
              <p>
                Culinary experiments documented as responsive micro-sites, highlighting craft and
                sensory memory.
              </p>
            </li>
          </ul>
        </section>

        <!-- Contact Section -->
        <section class="content-section" id="contact">
          <h2>Contact</h2>
          <p>
            Reach out for collaborations, research inquiries, or to swap ride routes:
            <a href="mailto:hello@clarenceyeung.com">hello@clarenceyeung.com</a>
          </p>
          <p class="contact-links">
            <a href="https://www.linkedin.com" target="_blank" rel="noopener">LinkedIn</a>
            <span aria-hidden="true">·</span>
            <a href="https://github.com" target="_blank" rel="noopener">GitHub</a>
            <span aria-hidden="true">·</span>
            <a href="https://scholar.google.com" target="_blank" rel="noopener">Google Scholar</a>
            <span aria-hidden="true">·</span>
            <a href="https://clarenceyeung.substack.com" target="_blank" rel="noopener">Substack</a>
          </p>
        </section>
      </section>
    </main>

    <script type="module">
      import * as THREE from 'three';
      import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
      import { BufferGeometryUtils } from 'three/examples/jsm/utils/BufferGeometryUtils.js';

      /* ---------------------------------------- */
      /* Minimal Globe Setup                      */
      /* ---------------------------------------- */
      const stage = document.getElementById('globe-stage');
      const tooltip = document.getElementById('globe-tooltip');

      const globeScene = new THREE.Scene();
      const globeCamera = new THREE.PerspectiveCamera(40, 1, 0.1, 1000);
      const globeRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      globeRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      globeRenderer.outputColorSpace = THREE.SRGBColorSpace;
      globeRenderer.toneMapping = THREE.ACESFilmicToneMapping;
      globeRenderer.toneMappingExposure = 1.05;
      globeRenderer.setClearColor(0x000000, 0);
      stage.appendChild(globeRenderer.domElement);
      globeRenderer.domElement.style.cursor = 'grab';
      globeRenderer.domElement.style.outline = 'none';
      globeRenderer.domElement.addEventListener('pointerdown', () => {
        globeRenderer.domElement.style.cursor = 'grabbing';
      });
      ['pointerup', 'pointerleave'].forEach((evt) => {
        globeRenderer.domElement.addEventListener(evt, () => {
          globeRenderer.domElement.style.cursor = 'grab';
        });
      });

      const globeGroup = new THREE.Group();
      globeScene.add(globeGroup);

      const globeRadius = 3.2;

      const oceanMaterial = new THREE.MeshLambertMaterial({ color: '#d5d9c7' });
      const oceanMesh = new THREE.Mesh(new THREE.SphereGeometry(globeRadius, 128, 128), oceanMaterial);
      globeGroup.add(oceanMesh);

      const landMaterial = new THREE.MeshLambertMaterial({
        color: '#9aa07a',
        transparent: true,
        opacity: 0.92,
        side: THREE.DoubleSide,
        polygonOffset: true,
        polygonOffsetFactor: -0.5,
        polygonOffsetUnits: -0.5,
      });
      const landGroup = new THREE.Group();
      globeGroup.add(landGroup);

      const landDebugGroup = new THREE.Group();
      landDebugGroup.visible = false;
      globeGroup.add(landDebugGroup);

      const markerGroup = new THREE.Group();
      globeGroup.add(markerGroup);

      const ambientLight = new THREE.AmbientLight(0xf5f4ed, 0.6);
      globeScene.add(ambientLight);
      const sunLight = new THREE.DirectionalLight(0xffffff, 0.85);
      sunLight.position.set(-6.5, 7.5, 6.5);
      globeScene.add(sunLight);

      globeCamera.position.set(0, 0, globeRadius * 4.2);

      const controls = new OrbitControls(globeCamera, globeRenderer.domElement);
      controls.enablePan = false;
      controls.enableDamping = true;
      controls.dampingFactor = 0.08;
      controls.enableZoom = true;
      controls.minDistance = globeRadius * 1.6;
      controls.maxDistance = globeRadius * 4.8;

      let userIsInteracting = false;
      controls.addEventListener('start', () => {
        userIsInteracting = true;
      });
      controls.addEventListener('end', () => {
        userIsInteracting = false;
      });

      globeGroup.rotation.x = THREE.MathUtils.degToRad(18);

      const convertLatLonToXYZ = (lat, lon, radius) => {
        if (!Number.isFinite(lat) || !Number.isFinite(lon) || !Number.isFinite(radius) || radius <= 0) {
          console.warn('[Globe] Invalid lat/lon/radius supplied to convertLatLonToXYZ', {
            lat,
            lon,
            radius,
          });
          return new THREE.Vector3(0, 0, 0);
        }
        const phi = THREE.MathUtils.degToRad(90 - lat);
        const theta = THREE.MathUtils.degToRad(lon + 180);
        const x = -radius * Math.sin(phi) * Math.cos(theta);
        const z = radius * Math.sin(phi) * Math.sin(theta);
        const y = radius * Math.cos(phi);
        return new THREE.Vector3(x, y, z);
      };

      const ensureClosedRing = (ring) => {
        if (!Array.isArray(ring) || ring.length < 3) return [];
        const closed = ring.map(([lon, lat]) => [lon, lat]);
        const [firstLon, firstLat] = closed[0];
        const [lastLon, lastLat] = closed[closed.length - 1];
        if (firstLon !== lastLon || firstLat !== lastLat) {
          closed.push([firstLon, firstLat]);
        }
        return closed;
      };

      const ringArea = (ring) => {
        let sum = 0;
        for (let i = 0; i < ring.length - 1; i++) {
          const [x1, y1] = ring[i];
          const [x2, y2] = ring[i + 1];
          sum += x1 * y2 - x2 * y1;
        }
        return sum / 2;
      };

      const unwrapRing = (ring) => {
        const unwrapped = [];
        let offset = 0;
        for (let i = 0; i < ring.length; i++) {
          const [lon, lat] = ring[i];
          if (i > 0) {
            const prevLon = unwrapped[i - 1][0];
            const delta = lon + offset - prevLon;
            if (delta > 180) {
              offset -= 360;
            } else if (delta < -180) {
              offset += 360;
            }
          }
          unwrapped.push([lon + offset, lat]);
        }
        return unwrapped;
      };

      const flagDatelineCrossing = (segment, featureId, ringIndex) => {
        console.warn(
          `Dateline crossing detected in feature ${featureId ?? 'unknown'} ring ${ringIndex}. Segment split for stability.`
        );
        const debugPositions = [];
        const landRadius = globeRadius + 0.05;
        segment.forEach(([lon, lat]) => {
          const normalizedLon = ((lon % 360) + 540) % 360 - 180;
          const vertex = convertLatLonToXYZ(lat, normalizedLon, landRadius);
          debugPositions.push(vertex.x, vertex.y, vertex.z);
        });
        if (debugPositions.length >= 9) {
          const debugGeometry = new THREE.BufferGeometry();
          debugGeometry.setAttribute(
            'position',
            new THREE.Float32BufferAttribute(debugPositions, 3)
          );
          const debugMaterial = new THREE.LineBasicMaterial({ color: 0xd04d4d, transparent: true, opacity: 0.7 });
          const debugLoop = new THREE.LineLoop(debugGeometry, debugMaterial);
          landDebugGroup.visible = true;
          landDebugGroup.add(debugLoop);
        }
      };

      const splitRingByDateline = (ring, featureId, ringIndex = 0) => {
        if (!Array.isArray(ring) || ring.length < 4) return [];
        const segments = [];
        let currentSegment = [[...ring[0]]];
        for (let i = 0; i < ring.length - 1; i++) {
          const start = currentSegment[currentSegment.length - 1];
          const end = [...ring[i + 1]];
          const lonDiff = end[0] - start[0];
          if (Math.abs(lonDiff) > 150) {
            console.debug(
              `Large longitudinal edge detected (${lonDiff.toFixed(2)}°) in feature ${featureId ?? 'unknown'} ring ${ringIndex}.`
            );
          }
          if (Math.abs(lonDiff) > 180) {
            const crossingLon = lonDiff > 0 ? 180 : -180;
            const wrappedLon = lonDiff > 0 ? -180 : 180;
            const t = (crossingLon - start[0]) / (end[0] - start[0]);
            const crossingLat = THREE.MathUtils.lerp(start[1], end[1], t);
            const crossingPointNear = [crossingLon, crossingLat];
            const crossingPointFar = [wrappedLon, crossingLat];
            currentSegment.push(crossingPointNear);
            segments.push(ensureClosedRing(currentSegment));
            flagDatelineCrossing(currentSegment, featureId, ringIndex);
            currentSegment = [crossingPointFar, end];
          } else {
            currentSegment.push(end);
          }
        }
        if (currentSegment.length > 2) {
          segments.push(ensureClosedRing(currentSegment));
        }
        if (segments.length === 0) {
          segments.push(ensureClosedRing(ring.map(([lon, lat]) => [lon, lat])));
        }
        return segments;
      };

      const preprocessRing = (ring, featureId, ringIndex = 0) => {
        if (!Array.isArray(ring)) return [];
        const filtered = ring
          .filter((coord) => Array.isArray(coord) && coord.length >= 2)
          .map(([lon, lat]) => [
            ((lon + 540) % 360) - 180,
            Math.max(-90, Math.min(90, lat)),
          ]);
        if (filtered.length < 3) return [];
        const closed = ensureClosedRing(filtered);
        const datelineSegments = splitRingByDateline(closed, featureId, ringIndex);
        if (datelineSegments.length > 1) {
          datelineSplitCount += datelineSegments.length - 1;
        }
        return datelineSegments
          .map((segment) => unwrapRing(segment))
          .map((segment) => {
            const area = ringArea(segment);
            if (Math.abs(area) < 1e-5) {
              console.warn(
                `Discarding near-zero area ring in feature ${featureId ?? 'unknown'} ring ${ringIndex}.`
              );
              return null;
            }
            if (area < 0) {
              segment.reverse();
            }
            return segment;
          })
          .filter(Boolean);
      };

      const preparePolygonSegments = (rings, featureId) => {
        if (!Array.isArray(rings) || rings.length === 0) return [];
        const outerSegments = preprocessRing(rings[0], featureId, 0);
        if (!outerSegments.length) return [];
        const removeInteriorHoles = true;
        if (removeInteriorHoles || rings.length === 1) {
          return outerSegments.map((segment) => ({ outer: segment, holes: [] }));
        }

        const processedHoles = rings.slice(1).map((ring, index) => preprocessRing(ring, featureId, index + 1)).flat();
        const orientedHoles = processedHoles
          .map((segment) => {
            const area = ringArea(segment);
            if (Math.abs(area) < 1e-5) return null;
            if (area > 0) {
              segment.reverse();
            }
            return segment;
          })
          .filter(Boolean);

        return outerSegments.map((segment) => ({ outer: segment, holes: removeInteriorHoles ? [] : orientedHoles }));
      };

      const landGeometries = [];
      const fallbackRings = [];
      const landStats = {
        features: 0,
        polygons: 0,
        segments: 0,
        rings: 0,
        vertices: 0,
      };
      const landBounds = {
        min: new THREE.Vector3(Infinity, Infinity, Infinity),
        max: new THREE.Vector3(-Infinity, -Infinity, -Infinity),
      };
      let datelineSplitCount = 0;

      const resetLandDiagnostics = () => {
        landGeometries.length = 0;
        fallbackRings.length = 0;
        landStats.features = 0;
        landStats.polygons = 0;
        landStats.segments = 0;
        landStats.rings = 0;
        landStats.vertices = 0;
        datelineSplitCount = 0;
        landBounds.min.set(Infinity, Infinity, Infinity);
        landBounds.max.set(-Infinity, -Infinity, -Infinity);
      };

      const updateBounds = (vertex) => {
        landBounds.min.x = Math.min(landBounds.min.x, vertex.x);
        landBounds.min.y = Math.min(landBounds.min.y, vertex.y);
        landBounds.min.z = Math.min(landBounds.min.z, vertex.z);
        landBounds.max.x = Math.max(landBounds.max.x, vertex.x);
        landBounds.max.y = Math.max(landBounds.max.y, vertex.y);
        landBounds.max.z = Math.max(landBounds.max.z, vertex.z);
      };

      const attributeHasInvalidValues = (attribute) => {
        if (!attribute) return true;
        for (let i = 0; i < attribute.count; i++) {
          const x = attribute.getX(i);
          const y = attribute.getY(i);
          const z = attribute.getZ(i);
          if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(z)) {
            console.warn('[Globe] Invalid vertex encountered', { index: i, x, y, z });
            return true;
          }
        }
        return false;
      };

      const drawFallbackOutlines = () => {
        if (!fallbackRings.length) return;
        landDebugGroup.clear();
        fallbackRings.forEach(({ coords, featureId }) => {
          if (!Array.isArray(coords) || coords.length < 3) return;
          const outlinePositions = [];
          coords.forEach(([lon, lat]) => {
            const normalizedLon = ((lon % 360) + 540) % 360 - 180;
            const vertex = convertLatLonToXYZ(lat, normalizedLon, globeRadius + 0.04);
            outlinePositions.push(vertex.x, vertex.y, vertex.z);
          });
          if (outlinePositions.length < 9) return;
          const outlineGeometry = new THREE.BufferGeometry();
          outlineGeometry.setAttribute(
            'position',
            new THREE.Float32BufferAttribute(outlinePositions, 3)
          );
          const outlineMaterial = new THREE.LineBasicMaterial({
            color: 0x9aa07a,
            transparent: true,
            opacity: 0.9,
          });
          const outlineLoop = new THREE.LineLoop(outlineGeometry, outlineMaterial);
          outlineLoop.name = `FallbackOutline-${featureId ?? 'unknown'}`;
          landDebugGroup.add(outlineLoop);
        });
        if (landDebugGroup.children.length) {
          console.warn('[Globe] Rendering fallback land outlines for debugging.');
          landDebugGroup.visible = true;
        }
      };

      const buildPolygon = (rings, featureId) => {
        const segments = preparePolygonSegments(rings, featureId);
        if (!segments.length) return;
        landStats.polygons += 1;
        landStats.rings += Array.isArray(rings) ? rings.length : 0;
        segments.forEach(({ outer, holes }) => {
          landStats.segments += 1;
          fallbackRings.push({ coords: outer, featureId });
          const shape = new THREE.Shape();
          outer.forEach(([lon, lat], index) => {
            if (index === 0) {
              shape.moveTo(lon, lat);
            } else {
              shape.lineTo(lon, lat);
            }
          });
          shape.closePath();

          const holePaths = (holes || []).map((hole) => {
            const path = new THREE.Path();
            hole.forEach(([lon, lat], index) => {
              if (index === 0) {
                path.moveTo(lon, lat);
              } else {
                path.lineTo(lon, lat);
              }
            });
            path.closePath();
            return path;
          });

          const geometry = new THREE.ShapeGeometry(shape, holePaths);
          const position = geometry.attributes.position;
          if (!position || position.count === 0) {
            console.warn('[Globe] Empty geometry after ShapeGeometry creation', { featureId });
            geometry.dispose();
            return;
          }
          const landRadius = globeRadius + 0.02;
          const convertedVertices = [];
          let invalidVertexDetected = false;
          for (let i = 0; i < position.count; i++) {
            const lon = position.getX(i);
            const lat = position.getY(i);
            if (!Number.isFinite(lat) || !Number.isFinite(lon)) {
              console.warn('[Globe] Non-finite lat/lon detected', { featureId, lon, lat, index: i });
              invalidVertexDetected = true;
              break;
            }
            const normalizedLon = ((lon % 360) + 540) % 360 - 180;
            const vertex = convertLatLonToXYZ(lat, normalizedLon, landRadius);
            if (!Number.isFinite(vertex.x) || !Number.isFinite(vertex.y) || !Number.isFinite(vertex.z)) {
              console.warn('[Globe] Non-finite vertex produced during projection', {
                featureId,
                lon,
                lat,
                vertex,
              });
              invalidVertexDetected = true;
              break;
            }
            convertedVertices.push(vertex);
          }
          if (invalidVertexDetected || convertedVertices.length !== position.count) {
            console.warn('[Globe] Discarding polygon with invalid vertices', { featureId });
            geometry.dispose();
            return;
          }
          convertedVertices.forEach((vertex, index) => {
            updateBounds(vertex);
            position.setXYZ(index, vertex.x, vertex.y, vertex.z);
          });
          position.needsUpdate = true;
          geometry.computeVertexNormals();
          geometry.computeBoundingSphere();
          landStats.vertices += position.count;
          landGeometries.push(geometry);
        });
      };

      const finalizeLandGeometry = () => {
        if (!landGeometries.length) {
          console.error('[Globe] No land geometries were generated.');
          drawFallbackOutlines();
          return;
        }
        const merged = BufferGeometryUtils.mergeGeometries(landGeometries, false);
        if (!merged) {
          console.error('[Globe] Merging land geometries failed. Rendering fallback outlines.');
          drawFallbackOutlines();
          return;
        }
        const position = merged.attributes.position;
        if (!position || position.count === 0 || attributeHasInvalidValues(position)) {
          console.error('[Globe] Invalid merged land geometry detected.', {
            vertexCount: position?.count ?? 0,
          });
          drawFallbackOutlines();
          return;
        }
        merged.computeBoundingSphere();
        merged.computeVertexNormals();
        merged.clearGroups();
        const landMesh = new THREE.Mesh(merged, landMaterial);
        landMesh.name = 'LandMesh';
        landMesh.frustumCulled = false;
        landGroup.add(landMesh);
        console.info('[Globe] Land mesh added to scene', {
          features: landStats.features,
          polygons: landStats.polygons,
          segments: landStats.segments,
          rings: landStats.rings,
          vertices: landStats.vertices,
          datelineSplits: datelineSplitCount,
          bounds: {
            min: landBounds.min.toArray(),
            max: landBounds.max.toArray(),
          },
        });
      };

      const loadLandPolygons = async () => {
        try {
          const response = await fetch(
            'https://raw.githubusercontent.com/datasets/geo-boundaries-world-110m/master/countries.geojson'
          );
          if (!response.ok) throw new Error('Failed to load land GeoJSON');
          const data = await response.json();
          const features = Array.isArray(data.features) ? data.features : [];
          resetLandDiagnostics();
          landStats.features = features.length;
          console.info(`[Globe] Loaded ${features.length} GeoJSON features.`);
          if (features.length === 0) {
            console.warn('[Globe] GeoJSON dataset returned no features.');
          }
          landGroup.clear();
          landDebugGroup.clear();
          landDebugGroup.visible = false;
          features.forEach((feature) => {
            const geometry = feature && feature.geometry;
            if (!geometry) return;
            if (geometry.type === 'Polygon') {
              buildPolygon(geometry.coordinates, feature.id || feature.properties?.name);
            } else if (geometry.type === 'MultiPolygon') {
              geometry.coordinates.forEach((polygonRings) =>
                buildPolygon(polygonRings, feature.id || feature.properties?.name)
              );
            }
          });
          finalizeLandGeometry();
          if (landGroup.children.length < 1) {
            console.warn('[Globe] Land mesh missing after finalize; showing fallback outlines.');
            drawFallbackOutlines();
          }
        } catch (error) {
          console.error('Unable to build land polygons', error);
        }
      };

      loadLandPolygons();

      const markerMeshes = [];
      let hoveredMarker = null;
      const raycaster = new THREE.Raycaster();
      const pointer = new THREE.Vector2();

      const createMarker = (activity) => {
        const { lat, lon, name, id } = activity;
        const position = convertLatLonToXYZ(lat, lon, globeRadius + 0.02);
        const material = new THREE.MeshStandardMaterial({
          color: new THREE.Color('#636B2F'),
          emissive: new THREE.Color('#636B2F'),
          emissiveIntensity: 0.08,
          transparent: true,
          opacity: 0.7,
          roughness: 0.45,
          metalness: 0.08,
        });
        const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.08, 28, 28), material);
        mesh.position.copy(position);
        mesh.lookAt(new THREE.Vector3(0, 0, 0));
        mesh.userData = {
          id,
          name,
          lat,
          lon,
          baseEmissive: material.emissiveIntensity,
          baseOpacity: material.opacity,
        };
        markerGroup.add(mesh);
        markerMeshes.push(mesh);
      };

      const resetHover = () => {
        if (!hoveredMarker) return;
        hoveredMarker.material.emissiveIntensity = hoveredMarker.userData.baseEmissive;
        hoveredMarker.material.opacity = hoveredMarker.userData.baseOpacity;
        hoveredMarker.scale.set(1, 1, 1);
        hoveredMarker = null;
        tooltip.hidden = true;
      };

      const setHover = (marker, event) => {
        if (hoveredMarker !== marker) {
          resetHover();
          hoveredMarker = marker;
          marker.material.emissiveIntensity = 0.35;
          marker.material.opacity = 0.95;
          marker.scale.set(1.45, 1.45, 1.45);
          tooltip.textContent = marker.userData.name || 'Activity';
          tooltip.hidden = false;
        }
        const rect = globeRenderer.domElement.getBoundingClientRect();
        tooltip.style.left = `${event.clientX - rect.left + 12}px`;
        tooltip.style.top = `${event.clientY - rect.top - 12}px`;
      };

      const onMarkerClick = (marker) => {
        const { id, lat, lon } = marker.userData;
        const url = `https://www.google.com/maps/search/?api=1&query=${lat.toFixed(5)},${lon.toFixed(5)}`;
        window.open(url, '_blank', 'noopener');
        if (typeof window.onGlobeMarkerClick === 'function') {
          window.onGlobeMarkerClick({ id, lat, lon });
        }
      };

      const updatePointerFromEvent = (event) => {
        const rect = globeRenderer.domElement.getBoundingClientRect();
        pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      };

      const handlePointerMove = (event) => {
        updatePointerFromEvent(event);
        raycaster.setFromCamera(pointer, globeCamera);
        const intersects = raycaster.intersectObjects(markerMeshes);
        if (intersects.length > 0) {
          setHover(intersects[0].object, event);
        } else {
          resetHover();
        }
      };

      const handlePointerLeave = () => {
        resetHover();
      };

      const handlePointerClick = (event) => {
        updatePointerFromEvent(event);
        raycaster.setFromCamera(pointer, globeCamera);
        const intersects = raycaster.intersectObjects(markerMeshes);
        if (intersects.length > 0) {
          const marker = intersects[0].object;
          onMarkerClick(marker);
        }
      };

      globeRenderer.domElement.addEventListener('pointermove', handlePointerMove);
      globeRenderer.domElement.addEventListener('pointerleave', handlePointerLeave);
      globeRenderer.domElement.addEventListener('click', handlePointerClick);

      const resizeGlobe = () => {
        const { clientWidth, clientHeight } = stage;
        if (!clientWidth || !clientHeight) return;
        globeRenderer.setSize(clientWidth, clientHeight, false);
        globeCamera.aspect = clientWidth / clientHeight;
        globeCamera.updateProjectionMatrix();
      };

      const loadActivities = async () => {
        try {
          const response = await fetch('assets/activities.json');
          if (!response.ok) throw new Error('Failed to load activities');
          const data = await response.json();
          resetHover();
          markerGroup.clear();
          markerMeshes.length = 0;
          (data.activities || []).forEach(createMarker);
        } catch (error) {
          console.warn(error);
        }
      };

      const animateGlobe = () => {
        requestAnimationFrame(animateGlobe);
        if (!userIsInteracting) {
          globeGroup.rotation.y += 0.00035;
        }
        controls.update();
        globeRenderer.render(globeScene, globeCamera);
      };

      resizeGlobe();
      window.addEventListener('resize', resizeGlobe);
      loadActivities();
      animateGlobe();

      const canvas = document.createElement('canvas');
      canvas.id = 'dna-helix';
      canvas.setAttribute('aria-hidden', 'true');
      document.body.appendChild(canvas);

      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
      renderer.setClearColor(0x000000, 0);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
      camera.position.set(0, 0, 16);
      camera.lookAt(0, 0, 0);

      const helixGroup = new THREE.Group();
      scene.add(helixGroup);

      const oliveColor = new THREE.Color('#636B2F');
      const baseOpacity = 0.5;

      const dotTexture = (() => {
        const size = 128;
        const texCanvas = document.createElement('canvas');
        texCanvas.width = texCanvas.height = size;
        const ctx = texCanvas.getContext('2d');
        const gradient = ctx.createRadialGradient(
          size / 2,
          size / 2,
          size * 0.1,
          size / 2,
          size / 2,
          size * 0.5
        );
        gradient.addColorStop(0, 'rgba(99,107,47,0.5)');
        gradient.addColorStop(1, 'rgba(99,107,47,0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, size, size);
        const texture = new THREE.CanvasTexture(texCanvas);
        texture.wrapS = texture.wrapT = THREE.ClampToEdgeWrapping;
        return texture;
      })();

      const segments = 900;
      const turns = 1.5;
      const helixHeight = 12.5;
      const helixRadius = 2.6;
      const rungInterval = 12;

      const strandPositions = [];
      const rungPositions = [];
      const pointPositions = [];
      const ambientPositions = [];
      const clusterPositions = [];
      const clusterLinkPositions = [];

      for (let i = 0; i <= segments; i++) {
        const progress = i / segments;
        const angle = progress * Math.PI * 2 * turns;
        const y = (progress - 0.5) * helixHeight;

        const baseX = Math.cos(angle) * helixRadius;
        const baseZ = Math.sin(angle) * helixRadius;
        const jitter = (Math.random() - 0.5) * 0.22;
        const x1 = baseX + jitter;
        const z1 = baseZ + jitter * 0.4;
        const x2 = -baseX + (Math.random() - 0.5) * 0.22;
        const z2 = -baseZ + (Math.random() - 0.5) * 0.22;

        pointPositions.push(x1, y, z1, x2, y, z2);

        if (i < segments) {
          const nextProgress = (i + 1) / segments;
          const nextAngle = nextProgress * Math.PI * 2 * turns;
          const nextY = (nextProgress - 0.5) * helixHeight;
          const nextBaseX = Math.cos(nextAngle) * helixRadius;
          const nextBaseZ = Math.sin(nextAngle) * helixRadius;
          const nextJitter = (Math.random() - 0.5) * 0.22;
          const nx1 = nextBaseX + nextJitter;
          const nz1 = nextBaseZ + nextJitter * 0.4;
          const nx2 = -nextBaseX + (Math.random() - 0.5) * 0.22;
          const nz2 = -nextBaseZ + (Math.random() - 0.5) * 0.22;

          strandPositions.push(x1, y, z1, nx1, nextY, nz1);
          strandPositions.push(x2, y, z2, nx2, nextY, nz2);
        }

        if (i % rungInterval === 0) {
          rungPositions.push(x1, y, z1, x2, y, z2);
        }

        if (i % 7 === 0) {
          const clusterSize = 16;
          for (let c = 0; c < clusterSize; c++) {
            const offsetRadius = helixRadius * (0.45 + Math.random() * 0.75);
            const offsetAngle = angle + (Math.random() - 0.5) * 1.1;
            const cx = Math.cos(offsetAngle) * offsetRadius + (Math.random() - 0.5) * 1.2;
            const cy = y + (Math.random() - 0.5) * 1.4;
            const cz = Math.sin(offsetAngle) * offsetRadius + (Math.random() - 0.5) * 1.2;

            clusterPositions.push(cx, cy, cz);
            clusterLinkPositions.push(cx, cy, cz, x1, y, z1);
          }
        }
      }

      const ambientCount = 2600;
      for (let i = 0; i < ambientCount; i++) {
        const spread = helixRadius * (0.9 + Math.random() * 1.1);
        const theta = Math.random() * Math.PI * 2 * turns;
        const y = (Math.random() - 0.5) * helixHeight * 1.1;
        const x = Math.cos(theta) * spread + (Math.random() - 0.5) * 0.7;
        const z = Math.sin(theta) * spread + (Math.random() - 0.5) * 0.7;
        ambientPositions.push(x, y, z);
      }

      const pointGeometry = new THREE.BufferGeometry();
      pointGeometry.setAttribute(
        'position',
        new THREE.Float32BufferAttribute(pointPositions, 3)
      );

      const strandGeometry = new THREE.BufferGeometry();
      strandGeometry.setAttribute(
        'position',
        new THREE.Float32BufferAttribute(strandPositions, 3)
      );

      const rungGeometry = new THREE.BufferGeometry();
      rungGeometry.setAttribute(
        'position',
        new THREE.Float32BufferAttribute(rungPositions, 3)
      );

      const ambientGeometry = new THREE.BufferGeometry();
      ambientGeometry.setAttribute(
        'position',
        new THREE.Float32BufferAttribute(ambientPositions, 3)
      );

      const clusterGeometry = new THREE.BufferGeometry();
      clusterGeometry.setAttribute(
        'position',
        new THREE.Float32BufferAttribute(clusterPositions, 3)
      );

      const clusterLinkGeometry = new THREE.BufferGeometry();
      clusterLinkGeometry.setAttribute(
        'position',
        new THREE.Float32BufferAttribute(clusterLinkPositions, 3)
      );

      const pointsMaterial = new THREE.PointsMaterial({
        map: dotTexture,
        alphaMap: dotTexture,
        color: oliveColor,
        size: 0.32,
        transparent: true,
        opacity: baseOpacity,
        blending: THREE.NormalBlending,
        depthWrite: false,
        sizeAttenuation: true,
      });

      const strandMaterial = new THREE.LineBasicMaterial({
        color: oliveColor,
        transparent: true,
        opacity: baseOpacity,
        blending: THREE.NormalBlending,
        depthWrite: false,
      });

      const rungMaterial = strandMaterial.clone();

      const ambientMaterial = new THREE.PointsMaterial({
        map: dotTexture,
        alphaMap: dotTexture,
        color: oliveColor,
        size: 0.22,
        transparent: true,
        opacity: baseOpacity,
        blending: THREE.NormalBlending,
        depthWrite: false,
        sizeAttenuation: true,
      });

      const clusterMaterial = new THREE.PointsMaterial({
        map: dotTexture,
        alphaMap: dotTexture,
        color: oliveColor,
        size: 0.28,
        transparent: true,
        opacity: baseOpacity,
        blending: THREE.NormalBlending,
        depthWrite: false,
        sizeAttenuation: true,
      });

      const clusterLinkMaterial = new THREE.LineBasicMaterial({
        color: oliveColor,
        transparent: true,
        opacity: baseOpacity,
        blending: THREE.NormalBlending,
        depthWrite: false,
      });

      helixGroup.add(new THREE.Points(pointGeometry, pointsMaterial));
      helixGroup.add(new THREE.LineSegments(strandGeometry, strandMaterial));
      helixGroup.add(new THREE.LineSegments(rungGeometry, rungMaterial));
      helixGroup.add(new THREE.Points(ambientGeometry, ambientMaterial));
      helixGroup.add(new THREE.Points(clusterGeometry, clusterMaterial));
      helixGroup.add(new THREE.LineSegments(clusterLinkGeometry, clusterLinkMaterial));

      helixGroup.scale.set(1.8, 0.45, 0.55);
      const baseRotation = new THREE.Euler(Math.PI / 5, Math.PI / 4, -Math.PI / 4);
      helixGroup.rotation.copy(baseRotation);

      const resizeRenderer = () => {
        const width = canvas.clientWidth;
        const height = canvas.clientHeight;
        if (!width || !height) return;
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(width, height, false);
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
      };

      window.addEventListener('resize', resizeRenderer);
      resizeRenderer();

      const maxScroll = () => document.body.scrollHeight - window.innerHeight;
      const baseRotationY = helixGroup.rotation.y;

      const updateScrollEffects = () => {
        const ratio = maxScroll() > 0 ? window.scrollY / maxScroll() : 0;
        const rotationRange = 0.45;
        helixGroup.rotation.y = baseRotationY + THREE.MathUtils.lerp(-rotationRange, rotationRange, ratio);
        const cameraTilt = THREE.MathUtils.lerp(-0.05, 0.04, ratio);
        camera.rotation.x = cameraTilt;
        canvas.style.opacity = (0.3 + (1 - ratio) * 0.15).toFixed(2);
      };

      window.addEventListener('scroll', updateScrollEffects, { passive: true });
      updateScrollEffects();

      const animate = () => {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
      };

      animate();
    </script>
  </body>
</html>
