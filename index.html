<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Clarence Yeung · Portfolio</title>
    <link rel="stylesheet" href="style.css" />
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.158/build/three.module.js",
          "three/examples/jsm/controls/OrbitControls.js": "https://cdn.jsdelivr.net/npm/three@0.158/examples/jsm/controls/OrbitControls.js"
        }
      }
    </script>
  </head>
  <body>
    <!-- Layout Wrapper -->
    <main class="page">
      <!-- Visual Placeholder Column -->
      <section class="visual-column">
        <div class="visual-container" role="presentation">
          <div class="visual-stage" id="globe-stage" aria-hidden="true"></div>
          <div
            class="visual-tooltip"
            id="globe-tooltip"
            role="status"
            aria-live="polite"
            hidden
          ></div>
        </div>
      </section>

      <!-- Content Column -->
      <section class="content-column">
        <header class="page-header">
          <div class="header-inner">
            <div class="hero-portrait" aria-hidden="true">
              <span>Portrait</span>
            </div>
            <h1>Clarence Yeung</h1>
          </div>
        </header>

        <!-- About Section -->
        <section class="content-section" id="about">
          <h2>About Me</h2>
          <nav aria-label="Primary links" class="about-links">
            <a href="https://www.linkedin.com" target="_blank" rel="noopener">LinkedIn</a>
            <span aria-hidden="true">·</span>
            <a href="https://scholar.google.com" target="_blank" rel="noopener"
              >Google Scholar</a
            >
            <span aria-hidden="true">·</span>
            <a href="https://github.com" target="_blank" rel="noopener">GitHub</a>
          </nav>
        </section>

        <!-- Projects Section -->
        <section class="content-section" id="projects">
          <h2>Projects</h2>
          <ul class="project-list">
            <li>
              <h3>Motion Atlas</h3>
              <p>
                A generative study that maps cycling telemetry into kinetic sculptures, pairing
                physics with visual storytelling.
              </p>
            </li>
            <li>
              <h3>Helix Studio</h3>
              <p>
                Interactive DNA narratives that invite visitors to manipulate molecular forms through
                touch and gesture.
              </p>
            </li>
            <li>
              <h3>Living Recipes</h3>
              <p>
                Culinary experiments documented as responsive micro-sites, highlighting craft and
                sensory memory.
              </p>
            </li>
          </ul>
        </section>

        <!-- Contact Section -->
        <section class="content-section" id="contact">
          <h2>Contact</h2>
          <p>
            Reach out for collaborations, research inquiries, or to swap ride routes:
            <a href="mailto:hello@clarenceyeung.com">hello@clarenceyeung.com</a>
          </p>
          <p class="contact-links">
            <a href="https://www.linkedin.com" target="_blank" rel="noopener">LinkedIn</a>
            <span aria-hidden="true">·</span>
            <a href="https://github.com" target="_blank" rel="noopener">GitHub</a>
            <span aria-hidden="true">·</span>
            <a href="https://scholar.google.com" target="_blank" rel="noopener">Google Scholar</a>
            <span aria-hidden="true">·</span>
            <a href="https://clarenceyeung.substack.com" target="_blank" rel="noopener">Substack</a>
          </p>
        </section>
      </section>
    </main>

    <script type="module">
      import * as THREE from 'three';
      import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

      /* ---------------------------------------- */
      /* Minimal Globe Setup                      */
      /* ---------------------------------------- */
      const stage = document.getElementById('globe-stage');
      const tooltip = document.getElementById('globe-tooltip');

      const globeScene = new THREE.Scene();
      const globeCamera = new THREE.PerspectiveCamera(40, 1, 0.1, 1000);
      const globeRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      globeRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      globeRenderer.outputColorSpace = THREE.SRGBColorSpace;
      globeRenderer.toneMapping = THREE.ACESFilmicToneMapping;
      globeRenderer.toneMappingExposure = 1.05;
      globeRenderer.setClearColor(0x000000, 0);
      stage.appendChild(globeRenderer.domElement);
      globeRenderer.domElement.style.cursor = 'grab';
      globeRenderer.domElement.style.outline = 'none';
      globeRenderer.domElement.addEventListener('pointerdown', () => {
        globeRenderer.domElement.style.cursor = 'grabbing';
      });
      ['pointerup', 'pointerleave'].forEach((evt) => {
        globeRenderer.domElement.addEventListener(evt, () => {
          globeRenderer.domElement.style.cursor = 'grab';
        });
      });

      const globeGroup = new THREE.Group();
      globeScene.add(globeGroup);

      const globeRadius = 3.2;

      const gradientTexture = (() => {
        const size = 1024;
        const texCanvas = document.createElement('canvas');
        texCanvas.width = texCanvas.height = size;
        const ctx = texCanvas.getContext('2d');
        const gradient = ctx.createRadialGradient(size * 0.32, size * 0.38, size * 0.1, size * 0.68, size * 0.68, size * 0.85);
        gradient.addColorStop(0, '#f5f4ef');
        gradient.addColorStop(0.55, '#e4e7d5');
        gradient.addColorStop(1, '#d1d7bd');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, size, size);
        const texture = new THREE.CanvasTexture(texCanvas);
        texture.colorSpace = THREE.SRGBColorSpace;
        return texture;
      })();

      const globeMaterial = new THREE.MeshStandardMaterial({
        map: gradientTexture,
        roughness: 0.35,
        metalness: 0.25,
        emissive: new THREE.Color('#d9ddca'),
        emissiveIntensity: 0.16,
      });
      const globeMesh = new THREE.Mesh(new THREE.SphereGeometry(globeRadius, 128, 128), globeMaterial);
      globeGroup.add(globeMesh);

      const atmosphereMaterial = new THREE.MeshPhongMaterial({
        color: new THREE.Color('#b4c0a0'),
        transparent: true,
        opacity: 0.18,
        side: THREE.BackSide,
        blending: THREE.AdditiveBlending,
      });
      const atmosphere = new THREE.Mesh(new THREE.SphereGeometry(globeRadius + 0.32, 64, 64), atmosphereMaterial);
      globeGroup.add(atmosphere);

      const horizonMaterial = new THREE.ShaderMaterial({
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        uniforms: {
          glowColor: { value: new THREE.Color('#9aa776') },
        },
        vertexShader: `
          varying vec3 vNormal;
          void main() {
            vNormal = normalize(normalMatrix * normal);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          varying vec3 vNormal;
          uniform vec3 glowColor;
          void main() {
            float intensity = pow(0.7 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 3.5);
            gl_FragColor = vec4(glowColor, intensity * 0.35);
          }
        `,
      });
      const horizon = new THREE.Mesh(new THREE.SphereGeometry(globeRadius + 0.18, 96, 96), horizonMaterial);
      globeGroup.add(horizon);

      const markerGroup = new THREE.Group();
      globeGroup.add(markerGroup);

      const starGeometry = new THREE.BufferGeometry();
      const starCount = 450;
      const starPositions = new Float32Array(starCount * 3);
      for (let i = 0; i < starCount; i++) {
        const angle = Math.random() * Math.PI * 2;
        const v = Math.random() * 2 - 1;
        const radius = globeRadius * (3.5 + Math.random() * 1.2);
        const sqrt = Math.sqrt(1 - v * v);
        starPositions[i * 3] = radius * sqrt * Math.cos(angle);
        starPositions[i * 3 + 1] = radius * v;
        starPositions[i * 3 + 2] = radius * sqrt * Math.sin(angle);
      }
      starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
      const starMaterial = new THREE.PointsMaterial({
        size: 0.015,
        color: '#d3d8c3',
        transparent: true,
        opacity: 0.45,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
      });
      const starField = new THREE.Points(starGeometry, starMaterial);
      globeScene.add(starField);

      const ambientLight = new THREE.AmbientLight(0xf2f1ea, 0.65);
      globeScene.add(ambientLight);
      const keyLight = new THREE.DirectionalLight(0xfaf8f0, 0.85);
      keyLight.position.set(-6.5, 7.5, 6.5);
      globeScene.add(keyLight);
      const rimLight = new THREE.DirectionalLight(0xcad1b1, 0.35);
      rimLight.position.set(5, -3, -4);
      globeScene.add(rimLight);

      globeCamera.position.set(0, 0, globeRadius * 4.2);

      const controls = new OrbitControls(globeCamera, globeRenderer.domElement);
      controls.enablePan = false;
      controls.enableDamping = true;
      controls.dampingFactor = 0.08;
      controls.enableZoom = true;
      controls.autoRotate = true;
      controls.autoRotateSpeed = 0.28;
      controls.minDistance = globeRadius * 1.6;
      controls.maxDistance = globeRadius * 4.8;
      controls.addEventListener('start', () => (controls.autoRotate = false));
      controls.addEventListener('end', () => (controls.autoRotate = true));

      globeGroup.rotation.x = THREE.MathUtils.degToRad(16);
      globeGroup.rotation.y = THREE.MathUtils.degToRad(-28);

      const markerMeshes = [];
      let hoveredMarker = null;
      const raycaster = new THREE.Raycaster();
      const pointer = new THREE.Vector2();

      const convertLatLonToXYZ = (lat, lon, radius) => {
        const phi = THREE.MathUtils.degToRad(90 - lat);
        const theta = THREE.MathUtils.degToRad(lon + 180);
        const x = -radius * Math.sin(phi) * Math.cos(theta);
        const z = radius * Math.sin(phi) * Math.sin(theta);
        const y = radius * Math.cos(phi);
        return new THREE.Vector3(x, y, z);
      };

      const createMarker = (activity) => {
        const { lat, lon, name, id } = activity;
        const position = convertLatLonToXYZ(lat, lon, globeRadius + 0.02);
        const material = new THREE.MeshStandardMaterial({
          color: new THREE.Color('#636B2F'),
          emissive: new THREE.Color('#636B2F'),
          emissiveIntensity: 0.22,
          transparent: true,
          opacity: 0.7,
          roughness: 0.35,
          metalness: 0.25,
        });
        const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.08, 28, 28), material);
        mesh.position.copy(position);
        mesh.lookAt(new THREE.Vector3(0, 0, 0));
        mesh.userData = {
          id,
          name,
          lat,
          lon,
          baseEmissive: material.emissiveIntensity,
          baseOpacity: material.opacity,
        };
        markerGroup.add(mesh);
        markerMeshes.push(mesh);
      };

      const resetHover = () => {
        if (!hoveredMarker) return;
        hoveredMarker.material.emissiveIntensity = hoveredMarker.userData.baseEmissive;
        hoveredMarker.material.opacity = hoveredMarker.userData.baseOpacity;
        hoveredMarker.scale.set(1, 1, 1);
        hoveredMarker = null;
        tooltip.hidden = true;
      };

      const setHover = (marker, event) => {
        if (hoveredMarker !== marker) {
          resetHover();
          hoveredMarker = marker;
          marker.material.emissiveIntensity = 0.95;
          marker.material.opacity = 0.95;
          marker.scale.set(1.65, 1.65, 1.65);
          tooltip.textContent = marker.userData.name || 'Activity';
          tooltip.hidden = false;
        }
        const rect = globeRenderer.domElement.getBoundingClientRect();
        tooltip.style.left = `${event.clientX - rect.left + 12}px`;
        tooltip.style.top = `${event.clientY - rect.top - 12}px`;
      };

      const onMarkerClick = (marker) => {
        const { id, lat, lon } = marker.userData;
        const url = `https://www.google.com/maps/search/?api=1&query=${lat.toFixed(5)},${lon.toFixed(5)}`;
        window.open(url, '_blank', 'noopener');
        if (typeof window.onGlobeMarkerClick === 'function') {
          window.onGlobeMarkerClick({ id, lat, lon });
        }
      };

      const updatePointerFromEvent = (event) => {
        const rect = globeRenderer.domElement.getBoundingClientRect();
        pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      };

      const handlePointerMove = (event) => {
        updatePointerFromEvent(event);
        raycaster.setFromCamera(pointer, globeCamera);
        const intersects = raycaster.intersectObjects(markerMeshes);
        if (intersects.length > 0) {
          setHover(intersects[0].object, event);
        } else {
          resetHover();
        }
      };

      const handlePointerLeave = () => {
        resetHover();
      };

      const handlePointerClick = (event) => {
        updatePointerFromEvent(event);
        raycaster.setFromCamera(pointer, globeCamera);
        const intersects = raycaster.intersectObjects(markerMeshes);
        if (intersects.length > 0) {
          const marker = intersects[0].object;
          onMarkerClick(marker);
        }
      };

      globeRenderer.domElement.addEventListener('pointermove', handlePointerMove);
      globeRenderer.domElement.addEventListener('pointerleave', handlePointerLeave);
      globeRenderer.domElement.addEventListener('click', handlePointerClick);

      const resizeGlobe = () => {
        const { clientWidth, clientHeight } = stage;
        if (!clientWidth || !clientHeight) return;
        globeRenderer.setSize(clientWidth, clientHeight, false);
        globeCamera.aspect = clientWidth / clientHeight;
        globeCamera.updateProjectionMatrix();
      };

      const loadActivities = async () => {
        try {
          const response = await fetch('assets/activities.json');
          if (!response.ok) throw new Error('Failed to load activities');
          const data = await response.json();
          resetHover();
          markerGroup.clear();
          markerMeshes.length = 0;
          (data.activities || []).forEach(createMarker);
        } catch (error) {
          console.warn(error);
        }
      };

      const animateGlobe = () => {
        requestAnimationFrame(animateGlobe);
        controls.update();
        starField.rotation.y += 0.0002;
        globeRenderer.render(globeScene, globeCamera);
      };

      resizeGlobe();
      window.addEventListener('resize', resizeGlobe);
      loadActivities();
      animateGlobe();

      const canvas = document.createElement('canvas');
      canvas.id = 'dna-helix';
      canvas.setAttribute('aria-hidden', 'true');
      document.body.appendChild(canvas);

      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
      renderer.setClearColor(0x000000, 0);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
      camera.position.set(0, 0, 16);
      camera.lookAt(0, 0, 0);

      const helixGroup = new THREE.Group();
      scene.add(helixGroup);

      const oliveColor = new THREE.Color('#636B2F');
      const baseOpacity = 0.5;

      const dotTexture = (() => {
        const size = 128;
        const texCanvas = document.createElement('canvas');
        texCanvas.width = texCanvas.height = size;
        const ctx = texCanvas.getContext('2d');
        const gradient = ctx.createRadialGradient(
          size / 2,
          size / 2,
          size * 0.1,
          size / 2,
          size / 2,
          size * 0.5
        );
        gradient.addColorStop(0, 'rgba(99,107,47,0.5)');
        gradient.addColorStop(1, 'rgba(99,107,47,0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, size, size);
        const texture = new THREE.CanvasTexture(texCanvas);
        texture.wrapS = texture.wrapT = THREE.ClampToEdgeWrapping;
        return texture;
      })();

      const segments = 900;
      const turns = 1.5;
      const helixHeight = 12.5;
      const helixRadius = 2.6;
      const rungInterval = 12;

      const strandPositions = [];
      const rungPositions = [];
      const pointPositions = [];
      const ambientPositions = [];
      const clusterPositions = [];
      const clusterLinkPositions = [];

      for (let i = 0; i <= segments; i++) {
        const progress = i / segments;
        const angle = progress * Math.PI * 2 * turns;
        const y = (progress - 0.5) * helixHeight;

        const baseX = Math.cos(angle) * helixRadius;
        const baseZ = Math.sin(angle) * helixRadius;
        const jitter = (Math.random() - 0.5) * 0.22;
        const x1 = baseX + jitter;
        const z1 = baseZ + jitter * 0.4;
        const x2 = -baseX + (Math.random() - 0.5) * 0.22;
        const z2 = -baseZ + (Math.random() - 0.5) * 0.22;

        pointPositions.push(x1, y, z1, x2, y, z2);

        if (i < segments) {
          const nextProgress = (i + 1) / segments;
          const nextAngle = nextProgress * Math.PI * 2 * turns;
          const nextY = (nextProgress - 0.5) * helixHeight;
          const nextBaseX = Math.cos(nextAngle) * helixRadius;
          const nextBaseZ = Math.sin(nextAngle) * helixRadius;
          const nextJitter = (Math.random() - 0.5) * 0.22;
          const nx1 = nextBaseX + nextJitter;
          const nz1 = nextBaseZ + nextJitter * 0.4;
          const nx2 = -nextBaseX + (Math.random() - 0.5) * 0.22;
          const nz2 = -nextBaseZ + (Math.random() - 0.5) * 0.22;

          strandPositions.push(x1, y, z1, nx1, nextY, nz1);
          strandPositions.push(x2, y, z2, nx2, nextY, nz2);
        }

        if (i % rungInterval === 0) {
          rungPositions.push(x1, y, z1, x2, y, z2);
        }

        if (i % 7 === 0) {
          const clusterSize = 16;
          for (let c = 0; c < clusterSize; c++) {
            const offsetRadius = helixRadius * (0.45 + Math.random() * 0.75);
            const offsetAngle = angle + (Math.random() - 0.5) * 1.1;
            const cx = Math.cos(offsetAngle) * offsetRadius + (Math.random() - 0.5) * 1.2;
            const cy = y + (Math.random() - 0.5) * 1.4;
            const cz = Math.sin(offsetAngle) * offsetRadius + (Math.random() - 0.5) * 1.2;

            clusterPositions.push(cx, cy, cz);
            clusterLinkPositions.push(cx, cy, cz, x1, y, z1);
          }
        }
      }

      const ambientCount = 2600;
      for (let i = 0; i < ambientCount; i++) {
        const spread = helixRadius * (0.9 + Math.random() * 1.1);
        const theta = Math.random() * Math.PI * 2 * turns;
        const y = (Math.random() - 0.5) * helixHeight * 1.1;
        const x = Math.cos(theta) * spread + (Math.random() - 0.5) * 0.7;
        const z = Math.sin(theta) * spread + (Math.random() - 0.5) * 0.7;
        ambientPositions.push(x, y, z);
      }

      const pointGeometry = new THREE.BufferGeometry();
      pointGeometry.setAttribute(
        'position',
        new THREE.Float32BufferAttribute(pointPositions, 3)
      );

      const strandGeometry = new THREE.BufferGeometry();
      strandGeometry.setAttribute(
        'position',
        new THREE.Float32BufferAttribute(strandPositions, 3)
      );

      const rungGeometry = new THREE.BufferGeometry();
      rungGeometry.setAttribute(
        'position',
        new THREE.Float32BufferAttribute(rungPositions, 3)
      );

      const ambientGeometry = new THREE.BufferGeometry();
      ambientGeometry.setAttribute(
        'position',
        new THREE.Float32BufferAttribute(ambientPositions, 3)
      );

      const clusterGeometry = new THREE.BufferGeometry();
      clusterGeometry.setAttribute(
        'position',
        new THREE.Float32BufferAttribute(clusterPositions, 3)
      );

      const clusterLinkGeometry = new THREE.BufferGeometry();
      clusterLinkGeometry.setAttribute(
        'position',
        new THREE.Float32BufferAttribute(clusterLinkPositions, 3)
      );

      const pointsMaterial = new THREE.PointsMaterial({
        map: dotTexture,
        alphaMap: dotTexture,
        color: oliveColor,
        size: 0.32,
        transparent: true,
        opacity: baseOpacity,
        blending: THREE.NormalBlending,
        depthWrite: false,
        sizeAttenuation: true,
      });

      const strandMaterial = new THREE.LineBasicMaterial({
        color: oliveColor,
        transparent: true,
        opacity: baseOpacity,
        blending: THREE.NormalBlending,
        depthWrite: false,
      });

      const rungMaterial = strandMaterial.clone();

      const ambientMaterial = new THREE.PointsMaterial({
        map: dotTexture,
        alphaMap: dotTexture,
        color: oliveColor,
        size: 0.22,
        transparent: true,
        opacity: baseOpacity,
        blending: THREE.NormalBlending,
        depthWrite: false,
        sizeAttenuation: true,
      });

      const clusterMaterial = new THREE.PointsMaterial({
        map: dotTexture,
        alphaMap: dotTexture,
        color: oliveColor,
        size: 0.28,
        transparent: true,
        opacity: baseOpacity,
        blending: THREE.NormalBlending,
        depthWrite: false,
        sizeAttenuation: true,
      });

      const clusterLinkMaterial = new THREE.LineBasicMaterial({
        color: oliveColor,
        transparent: true,
        opacity: baseOpacity,
        blending: THREE.NormalBlending,
        depthWrite: false,
      });

      helixGroup.add(new THREE.Points(pointGeometry, pointsMaterial));
      helixGroup.add(new THREE.LineSegments(strandGeometry, strandMaterial));
      helixGroup.add(new THREE.LineSegments(rungGeometry, rungMaterial));
      helixGroup.add(new THREE.Points(ambientGeometry, ambientMaterial));
      helixGroup.add(new THREE.Points(clusterGeometry, clusterMaterial));
      helixGroup.add(new THREE.LineSegments(clusterLinkGeometry, clusterLinkMaterial));

      helixGroup.scale.set(1.8, 0.45, 0.55);
      const baseRotation = new THREE.Euler(Math.PI / 5, Math.PI / 4, -Math.PI / 4);
      helixGroup.rotation.copy(baseRotation);

      const resizeRenderer = () => {
        const width = canvas.clientWidth;
        const height = canvas.clientHeight;
        if (!width || !height) return;
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(width, height, false);
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
      };

      window.addEventListener('resize', resizeRenderer);
      resizeRenderer();

      const maxScroll = () => document.body.scrollHeight - window.innerHeight;
      const baseRotationY = helixGroup.rotation.y;

      const updateScrollEffects = () => {
        const ratio = maxScroll() > 0 ? window.scrollY / maxScroll() : 0;
        const rotationRange = 0.45;
        helixGroup.rotation.y = baseRotationY + THREE.MathUtils.lerp(-rotationRange, rotationRange, ratio);
        const cameraTilt = THREE.MathUtils.lerp(-0.05, 0.04, ratio);
        camera.rotation.x = cameraTilt;
        canvas.style.opacity = (0.3 + (1 - ratio) * 0.15).toFixed(2);
      };

      window.addEventListener('scroll', updateScrollEffects, { passive: true });
      updateScrollEffects();

      const animate = () => {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
      };

      animate();
    </script>
  </body>
</html>
