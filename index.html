<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Clarence Yeung · Lab &amp; Larder Folio</title>
    <link rel="stylesheet" href="style.css" />
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.158/build/three.module.js",
          "three/examples/jsm/controls/OrbitControls.js": "https://cdn.jsdelivr.net/npm/three@0.158/examples/jsm/controls/OrbitControls.js"
        }
      }
    </script>
  </head>
  <body>
    <main class="recipe-layout">
      <section class="image-panel">
        <div class="image-surface" aria-hidden="true">
          <div class="image-photo">
            <div class="photo-overlay">Portrait placeholder</div>
          </div>
          <p class="image-caption">Moodboard: toasted cornmeal oatmeal cookies</p>
        </div>
        <div class="globe-shell">
          <div class="globe-header">
            <span class="globe-label">Ride atlas</span>
            <p class="globe-sub">Strava JSON rendered in Three.js</p>
          </div>
          <div class="globe-stage" id="globe-stage"></div>
          <div class="globe-tooltip" id="globe-tooltip" role="status" aria-live="polite" hidden></div>
          <p class="globe-note">Pins glow in mustard yellow to flag recent routes.</p>
        </div>
      </section>

      <section class="text-panel">
        <header class="title-block">
          <p class="title-issue">Lab &amp; Larder · Issue 01</p>
          <h1 class="recipe-title">Clarence Yeung</h1>
          <p class="servings-info">Serves: oncology discovery teams, supper club guests, long-distance climbs</p>
          <p class="intro">Scientist, cyclist, and experimental cook blending lab precision with kitchen warmth.</p>
          <p class="attribution">Recipe by Clarence Yeung · Hexagon Bio · San Francisco Bay Area</p>
          <nav aria-label="Personal links" class="profile-links">
            <a href="https://www.linkedin.com/in/clarence-yeung-8454237a/" target="_blank" rel="noopener">LinkedIn</a>
            <a href="https://github.com/cyeunghl" target="_blank" rel="noopener">GitHub</a>
            <a href="https://scholar.google.com/citations?user=sMj4W4EAAAAJ&amp;hl=en&amp;oi=ao" target="_blank" rel="noopener">Google Scholar</a>
            <a href="https://clarenceyeung.substack.com" target="_blank" rel="noopener">Substack</a>
          </nav>
        </header>

        <div class="divider" role="presentation"></div>

        <div class="content-columns">
          <section class="ingredients-column" aria-labelledby="ingredients-heading">
            <h2 id="ingredients-heading">Ingredients</h2>
            <ul class="ingredient-list">
              <li><span class="measure">250 g</span><span class="item">Genomics &amp; systems biology research</span></li>
              <li><span class="measure">180 g</span><span class="item">Computational variant interpretation pipelines</span></li>
              <li><span class="measure">120 g</span><span class="item">Collaborative lab leadership &amp; mentorship</span></li>
              <li><span class="measure">90 g</span><span class="item">Fermentation experiments &amp; recipe development</span></li>
              <li><span class="measure">Pinch</span><span class="item">Pop-up dinners with precision medicine storytelling</span></li>
            </ul>
            <p class="ingredients-note">All measures adaptable; season with curiosity and mustard-yellow data points.</p>
          </section>

          <section class="instructions-column" aria-labelledby="instructions-heading">
            <h2 id="instructions-heading">Instructions</h2>
            <p><strong>Preheat.</strong> Start in the lab, mapping genetic networks at Hexagon Bio to uncover novel oncology therapeutics.</p>
            <p><strong>Layer.</strong> Fold in computational rigor, translating raw sequencing data into actionable insights for cross-functional teams.</p>
            <p><strong>Plate.</strong> Serve findings alongside community suppers, weaving stories of precision medicine with seasonal menus and long rides.</p>

            <div class="strava-module" aria-labelledby="strava-heading">
              <div class="strava-header">
                <h3 id="strava-heading">Ride Pantry</h3>
                <p class="strava-sub">Heatmap and highlights sourced directly from Strava activity JSON.</p>
              </div>
              <div class="strava-summary" id="ride-summary" aria-live="polite">Loading seasonal stats…</div>
              <div class="strava-visuals">
                <figure class="heatmap-frame">
                  <canvas id="ride-heatmap" width="360" height="220" aria-label="Heatmap of logged rides"></canvas>
                  <figcaption>Global heatmap—warm tones indicate frequent routes.</figcaption>
                </figure>
                <div class="strava-list">
                  <h4>Featured Routes</h4>
                  <ol id="ride-feature-list" class="feature-list" aria-live="polite">
                    <li>Awaiting data from the latest rides.</li>
                  </ol>
                </div>
              </div>
            </div>
          </section>
        </div>

        <footer class="recipe-footnote">
          <p>Contact <a href="mailto:clarencehlyeung@gmail.com">clarencehlyeung@gmail.com</a> for collaborations, ride suggestions, or a favorite family recipe.</p>
          <p class="footnote">Adapted for web from the Lab &amp; Larder series · © <span id="year">2024</span></p>
        </footer>
      </section>
    </main>

    <script type="module">
      import * as THREE from 'three';
      import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

      /* ---------------------------------------- */
      /* Minimal Globe Setup                      */
      /* ---------------------------------------- */
      const stage = document.getElementById('globe-stage');
      const tooltip = document.getElementById('globe-tooltip');
      const yearStamp = document.getElementById('year');
      if (yearStamp) {
        yearStamp.textContent = new Date().getFullYear();
      }

      const globeScene = new THREE.Scene();
      const globeCamera = new THREE.PerspectiveCamera(40, 1, 0.1, 1000);
      const globeRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      globeRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      globeRenderer.outputColorSpace = THREE.SRGBColorSpace;
      globeRenderer.toneMapping = THREE.ACESFilmicToneMapping;
      globeRenderer.toneMappingExposure = 1.05;
      globeRenderer.setClearColor(0x000000, 0);
      stage.appendChild(globeRenderer.domElement);
      globeRenderer.domElement.style.cursor = 'grab';
      globeRenderer.domElement.style.outline = 'none';
      globeRenderer.domElement.addEventListener('pointerdown', () => {
        globeRenderer.domElement.style.cursor = 'grabbing';
      });
      ['pointerup', 'pointerleave'].forEach((evt) => {
        globeRenderer.domElement.addEventListener(evt, () => {
          globeRenderer.domElement.style.cursor = 'grab';
        });
      });

      const globeGroup = new THREE.Group();
      globeScene.add(globeGroup);

      const globeRadius = 3.2;

      const oceanMaterial = new THREE.MeshLambertMaterial({ color: '#d5d9c7' });
      const oceanMesh = new THREE.Mesh(new THREE.SphereGeometry(globeRadius, 128, 128), oceanMaterial);
      globeGroup.add(oceanMesh);

      const landMaterial = new THREE.MeshLambertMaterial({
        color: '#9aa07a',
        transparent: true,
        opacity: 0.92,
        side: THREE.DoubleSide,
      });
      const landGroup = new THREE.Group();
      globeGroup.add(landGroup);

      const markerGroup = new THREE.Group();
      globeGroup.add(markerGroup);

      const ambientLight = new THREE.AmbientLight(0xf5f4ed, 0.6);
      globeScene.add(ambientLight);
      const sunLight = new THREE.DirectionalLight(0xffffff, 0.85);
      sunLight.position.set(-6.5, 7.5, 6.5);
      globeScene.add(sunLight);

      globeCamera.position.set(0, 0, globeRadius * 4.2);

      const controls = new OrbitControls(globeCamera, globeRenderer.domElement);
      controls.enablePan = false;
      controls.enableDamping = true;
      controls.dampingFactor = 0.08;
      controls.enableZoom = true;
      controls.minDistance = globeRadius * 1.6;
      controls.maxDistance = globeRadius * 4.8;

      let userIsInteracting = false;
      controls.addEventListener('start', () => {
        userIsInteracting = true;
      });
      controls.addEventListener('end', () => {
        userIsInteracting = false;
      });

      globeGroup.rotation.x = THREE.MathUtils.degToRad(18);

      const convertLatLonToXYZ = (lat, lon, radius) => {
        const phi = THREE.MathUtils.degToRad(90 - lat);
        const theta = THREE.MathUtils.degToRad(lon + 180);
        const x = -radius * Math.sin(phi) * Math.cos(theta);
        const z = radius * Math.sin(phi) * Math.sin(theta);
        const y = radius * Math.cos(phi);
        return new THREE.Vector3(x, y, z);
      };

      const buildPolygon = (rings) => {
        if (!Array.isArray(rings) || rings.length === 0) return;
        const [outer, ...holes] = rings;
        if (!outer || outer.length < 3) return;

        const shape = new THREE.Shape();
        outer.forEach(([lon, lat], index) => {
          if (index === 0) {
            shape.moveTo(lon, lat);
          } else {
            shape.lineTo(lon, lat);
          }
        });

        const holePaths = holes
          .filter((hole) => Array.isArray(hole) && hole.length >= 3)
          .map((hole) => {
            const path = new THREE.Path();
            hole.forEach(([lon, lat], index) => {
              if (index === 0) {
                path.moveTo(lon, lat);
              } else {
                path.lineTo(lon, lat);
              }
            });
            return path;
          });

        const geometry = new THREE.ShapeGeometry(shape, holePaths);
        const position = geometry.attributes.position;
        const landRadius = globeRadius + 0.01;
        for (let i = 0; i < position.count; i++) {
          const lon = position.getX(i);
          const lat = position.getY(i);
          const vertex = convertLatLonToXYZ(lat, lon, landRadius);
          position.setXYZ(i, vertex.x, vertex.y, vertex.z);
        }
        position.needsUpdate = true;
        geometry.computeVertexNormals();

        const mesh = new THREE.Mesh(geometry, landMaterial);
        landGroup.add(mesh);
      };

      const loadLandPolygons = async () => {
        try {
          const response = await fetch(
            'https://raw.githubusercontent.com/datasets/geo-boundaries-world-110m/master/countries.geojson'
          );
          if (!response.ok) throw new Error('Failed to load land GeoJSON');
          const data = await response.json();
          const features = Array.isArray(data.features) ? data.features : [];
          features.forEach((feature) => {
            const geometry = feature && feature.geometry;
            if (!geometry) return;
            if (geometry.type === 'Polygon') {
              buildPolygon(geometry.coordinates);
            } else if (geometry.type === 'MultiPolygon') {
              geometry.coordinates.forEach(buildPolygon);
            }
          });
        } catch (error) {
          console.error('Unable to build land polygons', error);
        }
      };

      loadLandPolygons();

      const markerMeshes = [];
      let hoveredMarker = null;
      const raycaster = new THREE.Raycaster();
      const pointer = new THREE.Vector2();

      const createMarker = (activity) => {
        const { lat, lon, name, id } = activity;
        const position = convertLatLonToXYZ(lat, lon, globeRadius + 0.02);
        const material = new THREE.MeshStandardMaterial({
          color: new THREE.Color('#c18e57'),
          emissive: new THREE.Color('#c18e57'),
          emissiveIntensity: 0.12,
          transparent: true,
          opacity: 0.78,
          roughness: 0.35,
          metalness: 0.1,
        });
        const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.08, 28, 28), material);
        mesh.position.copy(position);
        mesh.lookAt(new THREE.Vector3(0, 0, 0));
        mesh.userData = {
          id,
          name,
          lat,
          lon,
          baseEmissive: material.emissiveIntensity,
          baseOpacity: material.opacity,
        };
        markerGroup.add(mesh);
        markerMeshes.push(mesh);
      };

      const resetHover = () => {
        if (!hoveredMarker) return;
        hoveredMarker.material.emissiveIntensity = hoveredMarker.userData.baseEmissive;
        hoveredMarker.material.opacity = hoveredMarker.userData.baseOpacity;
        hoveredMarker.scale.set(1, 1, 1);
        hoveredMarker = null;
        tooltip.hidden = true;
      };

      const setHover = (marker, event) => {
        if (hoveredMarker !== marker) {
          resetHover();
          hoveredMarker = marker;
          marker.material.emissiveIntensity = 0.4;
          marker.material.opacity = 0.98;
          marker.scale.set(1.45, 1.45, 1.45);
          tooltip.textContent = marker.userData.name || 'Activity';
          tooltip.hidden = false;
        }
        const rect = globeRenderer.domElement.getBoundingClientRect();
        tooltip.style.left = `${event.clientX - rect.left + 12}px`;
        tooltip.style.top = `${event.clientY - rect.top - 12}px`;
      };

      const onMarkerClick = (marker) => {
        const { id, lat, lon } = marker.userData;
        const url = `https://www.google.com/maps/search/?api=1&query=${lat.toFixed(5)},${lon.toFixed(5)}`;
        window.open(url, '_blank', 'noopener');
        if (typeof window.onGlobeMarkerClick === 'function') {
          window.onGlobeMarkerClick({ id, lat, lon });
        }
      };

      const updatePointerFromEvent = (event) => {
        const rect = globeRenderer.domElement.getBoundingClientRect();
        pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      };

      const handlePointerMove = (event) => {
        updatePointerFromEvent(event);
        raycaster.setFromCamera(pointer, globeCamera);
        const intersects = raycaster.intersectObjects(markerMeshes);
        if (intersects.length > 0) {
          setHover(intersects[0].object, event);
        } else {
          resetHover();
        }
      };

      const handlePointerLeave = () => {
        resetHover();
      };

      const handlePointerClick = (event) => {
        updatePointerFromEvent(event);
        raycaster.setFromCamera(pointer, globeCamera);
        const intersects = raycaster.intersectObjects(markerMeshes);
        if (intersects.length > 0) {
          const marker = intersects[0].object;
          onMarkerClick(marker);
        }
      };

      globeRenderer.domElement.addEventListener('pointermove', handlePointerMove);
      globeRenderer.domElement.addEventListener('pointerleave', handlePointerLeave);
      globeRenderer.domElement.addEventListener('click', handlePointerClick);

      const resizeGlobe = () => {
        const { clientWidth, clientHeight } = stage;
        if (!clientWidth || !clientHeight) return;
        globeRenderer.setSize(clientWidth, clientHeight, false);
        globeCamera.aspect = clientWidth / clientHeight;
        globeCamera.updateProjectionMatrix();
      };

      const generateActivityId = () => {
        if (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function') {
          return crypto.randomUUID();
        }
        return `ride-${Math.random().toString(36).slice(2, 10)}`;
      };

      const normalizeActivity = (activity) => {
        if (!activity || typeof activity !== 'object') return null;
        const getValue = (keys, fallback = null) => {
          for (const key of keys) {
            const value = activity[key];
            if (value !== undefined && value !== null && value !== '') {
              return value;
            }
          }
          return fallback;
        };

        const coordinates = getValue([
          'coordinates',
          'location',
          'latlng',
          'latLng',
          'start_latlng',
          'startLatLng',
        ]);
        const lat = Array.isArray(coordinates) ? Number(coordinates[0]) : Number(getValue(['lat', 'latitude']));
        const lon = Array.isArray(coordinates) ? Number(coordinates[1]) : Number(getValue(['lon', 'lng', 'longitude']));
        if (!Number.isFinite(lat) || !Number.isFinite(lon)) return null;

        return {
          id: getValue(['id', 'activity_id'], generateActivityId()),
          name: getValue(['name', 'title'], 'Untitled Ride'),
          type: getValue(['type', 'sport_type'], 'Ride'),
          distance: Number(getValue(['distance'], 0)),
          duration: Number(getValue(['moving_time', 'elapsed_time'], 0)),
          startDate: getValue(['start_date', 'startDate', 'date'], new Date().toISOString()),
          lat,
          lon,
          city: getValue(['location_city', 'city'], ''),
          country: getValue(['location_country', 'country'], ''),
        };
      };

      const rideSummary = document.getElementById('ride-summary');
      const rideFeatureList = document.getElementById('ride-feature-list');
      const heatmapCanvas = document.getElementById('ride-heatmap');

      const formatDistance = (meters) => {
        const km = meters / 1000;
        return km >= 100 ? `${km.toFixed(0)} km` : `${km.toFixed(1)} km`;
      };

      const formatDate = (dateString) => {
        const date = new Date(dateString);
        return date.toLocaleDateString(undefined, { month: 'short', day: 'numeric', year: 'numeric' });
      };

      const formatDuration = (seconds) => {
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.round((seconds % 3600) / 60);
        if (hours > 0) {
          return `${hours} h ${minutes.toString().padStart(2, '0')} m`;
        }
        return `${minutes} m`;
      };

      const renderSummary = (activities) => {
        if (!rideSummary) return;
        if (!activities.length) {
          rideSummary.innerHTML = '<p>No recorded rides yet—time to clip in.</p>';
          return;
        }

        const totalDistance = activities.reduce((sum, item) => sum + (item.distance || 0), 0);
        const totalDuration = activities.reduce((sum, item) => sum + (item.duration || 0), 0);
        const rides = activities.filter((item) => item.type && item.type.toLowerCase().includes('ride'));
        const runs = activities.filter((item) => item.type && item.type.toLowerCase().includes('run'));

        rideSummary.innerHTML = `
          <div class="summary-pair">
            <span class="summary-label">Total distance</span>
            <span class="summary-value">${formatDistance(totalDistance)}</span>
          </div>
          <div class="summary-pair">
            <span class="summary-label">Time outside</span>
            <span class="summary-value">${formatDuration(totalDuration)}</span>
          </div>
          <div class="summary-pair">
            <span class="summary-label">Rides logged</span>
            <span class="summary-value">${rides.length}</span>
          </div>
          <div class="summary-pair">
            <span class="summary-label">Runs logged</span>
            <span class="summary-value">${runs.length}</span>
          </div>
        `;

        const featured = [...rides]
          .sort((a, b) => b.distance - a.distance)
          .slice(0, 5);

        if (featured.length) {
          rideFeatureList.innerHTML = featured
            .map(
              (item) => `
                <li>
                  <span class="feature-title">${item.name}</span>
                  <span class="feature-meta">${formatDistance(item.distance)} · ${formatDate(item.startDate)}</span>
                </li>
              `
            )
            .join('');
        } else {
          rideFeatureList.innerHTML = '<li>No ride data yet—time to clip in.</li>';
        }
      };

      const drawHeatmap = (activities) => {
        if (!heatmapCanvas) return;
        const context = heatmapCanvas.getContext('2d');
        if (!context) return;

        const dpr = Math.min(window.devicePixelRatio || 1, 2);
        const width = heatmapCanvas.clientWidth || heatmapCanvas.width || 360;
        const height = heatmapCanvas.clientHeight || heatmapCanvas.height || 220;
        heatmapCanvas.width = width * dpr;
        heatmapCanvas.height = height * dpr;
        context.scale(dpr, dpr);

        context.clearRect(0, 0, width, height);
        context.fillStyle = '#f8f5ef';
        context.fillRect(0, 0, width, height);

        const points = activities
          .filter((item) => typeof item.lat === 'number' && typeof item.lon === 'number')
          .map((item) => ({
            x: ((item.lon + 180) / 360) * width,
            y: ((90 - item.lat) / 180) * height,
            weight: Math.min(Math.max(item.distance / 100000, 0.4), 2.2),
          }));

        points.forEach((point) => {
          const radius = 18 * point.weight;
          const gradient = context.createRadialGradient(point.x, point.y, 0, point.x, point.y, radius);
          gradient.addColorStop(0, 'rgba(193, 142, 87, 0.38)');
          gradient.addColorStop(1, 'rgba(193, 142, 87, 0)');
          context.fillStyle = gradient;
          context.beginPath();
          context.arc(point.x, point.y, radius, 0, Math.PI * 2);
          context.fill();
        });

        context.strokeStyle = 'rgba(193, 142, 87, 0.25)';
        context.lineWidth = 1;
        context.strokeRect(0.5, 0.5, width - 1, height - 1);
      };

      const loadActivities = async () => {
        try {
          const response = await fetch('assets/activities.json');
          if (!response.ok) throw new Error('Failed to load activities');
          const data = await response.json();

          const normalized = (data.activities || [])
            .map(normalizeActivity)
            .filter(Boolean);

          resetHover();
          markerGroup.clear();
          markerMeshes.length = 0;
          normalized.forEach(createMarker);

          renderSummary(normalized);
          drawHeatmap(normalized);
        } catch (error) {
          console.warn(error);
          rideSummary.textContent = 'Unable to reduce rides into view right now. Please refresh the page.';
          rideFeatureList.innerHTML = '<li>Heatmap paused—check your network connection.</li>';
        }
      };

      const animateGlobe = () => {
        requestAnimationFrame(animateGlobe);
        if (!userIsInteracting) {
          globeGroup.rotation.y += 0.00035;
        }
        controls.update();
        globeRenderer.render(globeScene, globeCamera);
      };

      resizeGlobe();
      window.addEventListener('resize', resizeGlobe);
      loadActivities();
      animateGlobe();

      const canvas = document.createElement('canvas');
      canvas.id = 'dna-helix';
      canvas.setAttribute('aria-hidden', 'true');
      document.body.appendChild(canvas);

      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
      renderer.setClearColor(0x000000, 0);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
      camera.position.set(0, 0, 16);
      camera.lookAt(0, 0, 0);

      const helixGroup = new THREE.Group();
      scene.add(helixGroup);

      const strandColorA = new THREE.Color('#111111');
      const strandColorB = new THREE.Color('#c18e57');

      const helixMaterialA = new THREE.MeshPhongMaterial({ color: strandColorA, shininess: 28 });
      const helixMaterialB = new THREE.MeshPhongMaterial({ color: strandColorB, shininess: 28 });

      const radius = 1.6;
      const tubeRadius = 0.08;
      const turns = 9;
      const segments = 420;
      const height = 8;

      const createHelixStrand = (phase, material) => {
        const points = [];
        for (let i = 0; i <= segments; i++) {
          const t = (i / segments) * Math.PI * 2 * turns;
          const x = Math.cos(t + phase) * radius;
          const y = ((i / segments) - 0.5) * height;
          const z = Math.sin(t + phase) * radius;
          points.push(new THREE.Vector3(x, y, z));
        }
        const curve = new THREE.CatmullRomCurve3(points);
        return new THREE.Mesh(new THREE.TubeGeometry(curve, segments, tubeRadius, 12, false), material);
      };

      const strandA = createHelixStrand(0, helixMaterialA);
      const strandB = createHelixStrand(Math.PI, helixMaterialB);
      helixGroup.add(strandA);
      helixGroup.add(strandB);

      const rungMaterial = new THREE.MeshStandardMaterial({ color: '#8d5524', metalness: 0.2, roughness: 0.7 });
      for (let i = 0; i < turns * 12; i++) {
        const t = (i / (turns * 12)) * Math.PI * 2 * turns;
        const x = Math.cos(t) * radius;
        const y = ((i / (turns * 12)) - 0.5) * height;
        const z = Math.sin(t) * radius;
        const rung = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, radius * 1.9, 6), rungMaterial);
        rung.position.set(0, y, 0);
        rung.rotation.z = Math.PI / 2;
        rung.rotation.y = t;
        helixGroup.add(rung);
      }

      const helixLight = new THREE.DirectionalLight('#ffffff', 1.1);
      helixLight.position.set(4, 6, 8);
      scene.add(helixLight);
      scene.add(new THREE.AmbientLight('#d9d2c4', 0.55));

      const animate = () => {
        requestAnimationFrame(animate);
        helixGroup.rotation.y += 0.003;
        renderer.render(scene, camera);
      };

      const resizeHelix = () => {
        const size = Math.min(window.innerWidth * 0.18, 260);
        renderer.setSize(size, size, false);
        camera.aspect = 1;
        camera.updateProjectionMatrix();
      };

      window.addEventListener('resize', resizeHelix);
      resizeHelix();
      animate();
    </script>
  </body>
</html>
