<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Three.js Monochrome Earth</title>
    <link rel="stylesheet" href="style.css" />
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.158/build/three.module.js",
          "three/examples/jsm/controls/OrbitControls.js": "https://cdn.jsdelivr.net/npm/three@0.158/examples/jsm/controls/OrbitControls.js",
          "three/examples/jsm/utils/BufferGeometryUtils.js": "https://cdn.jsdelivr.net/npm/three@0.158/examples/jsm/utils/BufferGeometryUtils.js"
        }
      }
    </script>
  </head>
  <body>
    <main class="layout">
      <header class="intro">
        <h1>Monochrome Earth Globe</h1>
        <p>
          This Three.js scene renders Natural Earth land polygons on a minimalist ocean sphere. Use the
          mouse or touch to orbit, pan, and zoom the planet.
        </p>
      </header>

      <section class="globe-panel" aria-label="Interactive monochrome Earth globe">
        <div id="globe-container" class="globe-stage"></div>
      </section>
    </main>

    <script type="module">
      import * as THREE from 'three';
      import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
      import { BufferGeometryUtils } from 'three/examples/jsm/utils/BufferGeometryUtils.js';

      const container = document.getElementById('globe-container');

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(40, 1, 0.1, 1000);
      camera.position.set(0, 0, 10);

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setClearColor(0x000000, 0);
      container.appendChild(renderer.domElement);

      const ambientLight = new THREE.AmbientLight(0xffffff, 0.45);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.75);
      directionalLight.position.set(5, 4, 6);
      scene.add(ambientLight, directionalLight);

      const globeGroup = new THREE.Group();
      scene.add(globeGroup);

      const globeRadius = 3.2;

      const oceanGeometry = new THREE.SphereGeometry(globeRadius, 128, 128);
      const oceanMaterial = new THREE.MeshLambertMaterial({ color: '#98a6b5' });
      const oceanMesh = new THREE.Mesh(oceanGeometry, oceanMaterial);
      globeGroup.add(oceanMesh);

      const landMaterial = new THREE.MeshLambertMaterial({
        color: '#6d7346',
        side: THREE.DoubleSide,
        polygonOffset: true,
        polygonOffsetFactor: -0.5,
        polygonOffsetUnits: -0.5,
      });

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enablePan = false;
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.autoRotate = true;
      controls.autoRotateSpeed = 0.4;

      const mouseState = { isPointerDown: false };
      renderer.domElement.addEventListener('pointerdown', () => {
        mouseState.isPointerDown = true;
      });
      renderer.domElement.addEventListener('pointerup', () => {
        mouseState.isPointerDown = false;
      });
      renderer.domElement.addEventListener('pointerleave', () => {
        mouseState.isPointerDown = false;
      });

      async function loadLand() {
        try {
          const response = await fetch(
            'https://raw.githubusercontent.com/nvkelso/natural-earth-vector/master/geojson/ne_50m_land.geojson'
          );
          if (!response.ok) {
            throw new Error(`Failed to fetch land data: ${response.status} ${response.statusText}`);
          }
          const geojson = await response.json();
          buildLandMeshes(geojson.features || []);
        } catch (error) {
          console.error('Unable to load Natural Earth land polygons.', error);
        }
      }

      function buildLandMeshes(features) {
        const geometries = [];

        for (const feature of features) {
          if (!feature || !feature.geometry) continue;
          const { type, coordinates } = feature.geometry;
          if (type === 'Polygon') {
            const geom = polygonToGeometry(coordinates);
            if (geom) geometries.push(geom);
          } else if (type === 'MultiPolygon') {
            for (const polygon of coordinates) {
              const geom = polygonToGeometry(polygon);
              if (geom) geometries.push(geom);
            }
          }
        }

        if (!geometries.length) {
          console.warn('No land geometries were generated from the GeoJSON dataset.');
          return;
        }

        const merged = BufferGeometryUtils.mergeGeometries(geometries, true);
        const landMesh = new THREE.Mesh(merged, landMaterial);
        globeGroup.add(landMesh);
      }

      function polygonToGeometry(rings) {
        if (!Array.isArray(rings) || rings.length === 0) return null;
        const shape = createShapeFromRings(rings);
        if (!shape) return null;
        const geometry = new THREE.ShapeGeometry(shape, 8);
        projectShapeGeometryToSphere(geometry, globeRadius + 0.015);
        geometry.computeVertexNormals();
        return geometry;
      }

      function createShapeFromRings(rings) {
        const outerRing = prepareRing(rings[0], true);
        if (!outerRing || outerRing.length < 3) return null;

        const shape = new THREE.Shape();
        movePathWithPoints(shape, outerRing);

        for (let i = 1; i < rings.length; i += 1) {
          const hole = prepareRing(rings[i], false);
          if (!hole || hole.length < 3) continue;
          const path = new THREE.Path();
          movePathWithPoints(path, hole);
          shape.holes.push(path);
        }

        return shape;
      }

      function prepareRing(rawRing, isExterior) {
        if (!Array.isArray(rawRing) || rawRing.length < 4) return null;
        const closed = closeRing(rawRing);
        const ring = closed.slice();
        const area = ringArea(ring);

        if (area !== 0) {
          const shouldReverse = (isExterior && area < 0) || (!isExterior && area > 0);
          if (shouldReverse) ring.reverse();
        }

        const filtered = [];
        for (let i = 0; i < ring.length - 1; i += 1) {
          const [lon, lat] = ring[i];
          if (Number.isNaN(lon) || Number.isNaN(lat)) continue;
          if (!filtered.length) {
            filtered.push(new THREE.Vector2(lon, lat));
            continue;
          }
          const prev = filtered[filtered.length - 1];
          if (Math.abs(prev.x - lon) < 1e-6 && Math.abs(prev.y - lat) < 1e-6) {
            continue;
          }
          filtered.push(new THREE.Vector2(lon, lat));
        }

        return filtered.length >= 3 ? filtered : null;
      }

      function movePathWithPoints(path, points) {
        if (!points || points.length === 0) return;
        const first = points[0];
        path.moveTo(first.x, first.y);
        for (let i = 1; i < points.length; i += 1) {
          const point = points[i];
          path.lineTo(point.x, point.y);
        }
        path.closePath();
      }

      function closeRing(ring) {
        const closed = ring.slice();
        const first = ring[0];
        const last = ring[ring.length - 1];
        if (Math.abs(first[0] - last[0]) > 1e-6 || Math.abs(first[1] - last[1]) > 1e-6) {
          closed.push(first);
        }
        return closed;
      }

      function ringArea(ring) {
        let sum = 0;
        for (let i = 0; i < ring.length - 1; i += 1) {
          const [x1, y1] = ring[i];
          const [x2, y2] = ring[i + 1];
          sum += x1 * y2 - x2 * y1;
        }
        return sum / 2;
      }

      function projectShapeGeometryToSphere(geometry, radius) {
        const position = geometry.getAttribute('position');
        const vector = new THREE.Vector3();

        for (let i = 0; i < position.count; i += 1) {
          const lon = position.getX(i);
          const lat = position.getY(i);
          const projected = convertLatLonToXYZ(lat, lon, radius);
          vector.copy(projected);
          position.setXYZ(i, vector.x, vector.y, vector.z);
        }

        position.needsUpdate = true;
      }

      function convertLatLonToXYZ(lat, lon, radius) {
        const phi = THREE.MathUtils.degToRad(90 - lat);
        const theta = THREE.MathUtils.degToRad(lon + 180);
        const x = -radius * Math.sin(phi) * Math.sin(theta);
        const y = radius * Math.cos(phi);
        const z = radius * Math.sin(phi) * Math.cos(theta);
        return new THREE.Vector3(x, y, z);
      }

      function handleResize() {
        const { clientWidth, clientHeight } = container;
        if (clientWidth === 0 || clientHeight === 0) return;
        renderer.setSize(clientWidth, clientHeight, false);
        camera.aspect = clientWidth / clientHeight;
        camera.updateProjectionMatrix();
      }

      window.addEventListener('resize', handleResize);
      handleResize();
      loadLand();

      renderer.setAnimationLoop(() => {
        controls.update();
        if (!mouseState.isPointerDown) {
          globeGroup.rotation.y += 0.0005;
        }
        renderer.render(scene, camera);
      });
    </script>
  </body>
</html>
