<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Clarence Yeung · Portfolio</title>
    <link rel="stylesheet" href="style.css" />
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.158/build/three.module.js",
          "three/examples/jsm/controls/OrbitControls.js": "https://cdn.jsdelivr.net/npm/three@0.158/examples/jsm/controls/OrbitControls.js"
        }
      }
    </script>
  </head>
  <body>
    <!-- Layout Wrapper -->
    <main class="page">
      <!-- Visual Placeholder Column -->
      <section class="visual-column">
        <div class="visual-container" role="presentation">
          <div class="visual-stage" id="globe-stage" aria-hidden="true"></div>
          <div
            class="visual-tooltip"
            id="globe-tooltip"
            role="status"
            aria-live="polite"
            hidden
          ></div>
        </div>
      </section>

      <!-- Content Column -->
      <section class="content-column">
        <header class="page-header">
          <div class="header-inner">
            <div class="hero-portrait" aria-hidden="true">
              <span>Portrait</span>
            </div>
            <h1>Clarence Yeung</h1>
          </div>
        </header>

        <!-- About Section -->
        <section class="content-section" id="about">
          <h2>About Me</h2>
          <nav aria-label="Primary links" class="about-links">
            <a href="https://www.linkedin.com" target="_blank" rel="noopener">LinkedIn</a>
            <span aria-hidden="true">·</span>
            <a href="https://scholar.google.com" target="_blank" rel="noopener"
              >Google Scholar</a
            >
            <span aria-hidden="true">·</span>
            <a href="https://github.com" target="_blank" rel="noopener">GitHub</a>
          </nav>
        </section>

        <!-- Projects Section -->
        <section class="content-section" id="projects">
          <h2>Projects</h2>
          <ul class="project-list">
            <li>
              <h3>Motion Atlas</h3>
              <p>
                A generative study that maps cycling telemetry into kinetic sculptures, pairing
                physics with visual storytelling.
              </p>
            </li>
            <li>
              <h3>Helix Studio</h3>
              <p>
                Interactive DNA narratives that invite visitors to manipulate molecular forms through
                touch and gesture.
              </p>
            </li>
            <li>
              <h3>Living Recipes</h3>
              <p>
                Culinary experiments documented as responsive micro-sites, highlighting craft and
                sensory memory.
              </p>
            </li>
          </ul>
        </section>

        <!-- Contact Section -->
        <section class="content-section" id="contact">
          <h2>Contact</h2>
          <p>
            Reach out for collaborations, research inquiries, or to swap ride routes:
            <a href="mailto:hello@clarenceyeung.com">hello@clarenceyeung.com</a>
          </p>
          <p class="contact-links">
            <a href="https://www.linkedin.com" target="_blank" rel="noopener">LinkedIn</a>
            <span aria-hidden="true">·</span>
            <a href="https://github.com" target="_blank" rel="noopener">GitHub</a>
            <span aria-hidden="true">·</span>
            <a href="https://scholar.google.com" target="_blank" rel="noopener">Google Scholar</a>
            <span aria-hidden="true">·</span>
            <a href="https://clarenceyeung.substack.com" target="_blank" rel="noopener">Substack</a>
          </p>
        </section>
      </section>
    </main>

    <script type="module">
      import * as THREE from 'three';
      import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

      /* ---------------------------------------- */
      /* Minimal Globe Setup                      */
      /* ---------------------------------------- */
      const stage = document.getElementById('globe-stage');
      const tooltip = document.getElementById('globe-tooltip');

      const globeScene = new THREE.Scene();
      const globeCamera = new THREE.PerspectiveCamera(40, 1, 0.1, 1000);
      const globeRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      globeRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      globeRenderer.outputColorSpace = THREE.SRGBColorSpace;
      globeRenderer.toneMapping = THREE.ACESFilmicToneMapping;
      globeRenderer.toneMappingExposure = 1.05;
      globeRenderer.setClearColor(0x000000, 0);
      stage.appendChild(globeRenderer.domElement);
      globeRenderer.domElement.style.cursor = 'grab';
      globeRenderer.domElement.style.outline = 'none';
      globeRenderer.domElement.addEventListener('pointerdown', () => {
        globeRenderer.domElement.style.cursor = 'grabbing';
      });
      ['pointerup', 'pointerleave'].forEach((evt) => {
        globeRenderer.domElement.addEventListener(evt, () => {
          globeRenderer.domElement.style.cursor = 'grab';
        });
      });

      const globeGroup = new THREE.Group();
      globeScene.add(globeGroup);

      const globeRadius = 3.2;

      const oceanMaterial = new THREE.MeshLambertMaterial({ color: '#d5d9c7' });
      const oceanMesh = new THREE.Mesh(new THREE.SphereGeometry(globeRadius, 128, 128), oceanMaterial);
      globeGroup.add(oceanMesh);

      const landMaterial = new THREE.MeshLambertMaterial({
        color: '#9aa07a',
        transparent: true,
        opacity: 0.92,
        side: THREE.DoubleSide,
      });
      const landGroup = new THREE.Group();
      globeGroup.add(landGroup);

      const markerGroup = new THREE.Group();
      globeGroup.add(markerGroup);

      const ambientLight = new THREE.AmbientLight(0xf5f4ed, 0.6);
      globeScene.add(ambientLight);
      const sunLight = new THREE.DirectionalLight(0xffffff, 0.85);
      sunLight.position.set(-6.5, 7.5, 6.5);
      globeScene.add(sunLight);

      globeCamera.position.set(0, 0, globeRadius * 4.2);

      const controls = new OrbitControls(globeCamera, globeRenderer.domElement);
      controls.enablePan = false;
      controls.enableDamping = true;
      controls.dampingFactor = 0.08;
      controls.enableZoom = true;
      controls.minDistance = globeRadius * 1.6;
      controls.maxDistance = globeRadius * 4.8;

      let userIsInteracting = false;
      controls.addEventListener('start', () => {
        userIsInteracting = true;
      });
      controls.addEventListener('end', () => {
        userIsInteracting = false;
      });

      globeGroup.rotation.x = THREE.MathUtils.degToRad(18);

      const convertLatLonToXYZ = (lat, lon, radius) => {
        const phi = THREE.MathUtils.degToRad(90 - lat);
        const theta = THREE.MathUtils.degToRad(lon + 180);
        const x = -radius * Math.sin(phi) * Math.cos(theta);
        const z = radius * Math.sin(phi) * Math.sin(theta);
        const y = radius * Math.cos(phi);
        return new THREE.Vector3(x, y, z);
      };

      const ensureClosedRing = (ring) => {
        if (ring.length < 3) return ring;
        const first = ring[0];
        const last = ring[ring.length - 1];
        if (first[0] !== last[0] || first[1] !== last[1]) {
          ring.push([...first]);
        }
        return ring;
      };

      const ringArea = (ring) => {
        let sum = 0;
        for (let i = 0; i < ring.length - 1; i++) {
          const [x1, y1] = ring[i];
          const [x2, y2] = ring[i + 1];
          sum += x1 * y2 - x2 * y1;
        }
        return sum / 2;
      };

      const normalizePolygonRings = (rings) => {
        if (!Array.isArray(rings) || rings.length === 0) return null;
        const cleaned = rings
          .map((ring) =>
            Array.isArray(ring)
              ? ensureClosedRing(
                  ring
                    .filter((coord) => Array.isArray(coord) && coord.length >= 2)
                    .map(([lon, lat]) => [
                      ((lon + 540) % 360) - 180,
                      Math.max(-90, Math.min(90, lat)),
                    ])
                )
              : null
          )
          .filter((ring) => ring && ring.length >= 4);
        if (cleaned.length === 0) return null;

        const outer = cleaned[0];
        if (ringArea(outer) < 0) {
          outer.reverse();
        }

        const removeInteriorHoles = true; // collapse lakes for filled silhouette
        const holes = removeInteriorHoles
          ? []
          : cleaned.slice(1).map((hole) => {
              if (ringArea(hole) > 0) {
                hole.reverse();
              }
              return hole;
            });

        return { outer, holes };
      };

      const buildPolygon = (rings) => {
        const normalized = normalizePolygonRings(rings);
        if (!normalized) return;
        const { outer, holes } = normalized;

        const shape = new THREE.Shape();
        outer.forEach(([lon, lat], index) => {
          if (index === 0) {
            shape.moveTo(lon, lat);
          } else {
            shape.lineTo(lon, lat);
          }
        });
        shape.closePath();

        const holePaths = holes.map((hole) => {
          const path = new THREE.Path();
          hole.forEach(([lon, lat], index) => {
            if (index === 0) {
              path.moveTo(lon, lat);
            } else {
              path.lineTo(lon, lat);
            }
          });
          path.closePath();
          return path;
        });

        const geometry = new THREE.ShapeGeometry(shape, holePaths);
        const position = geometry.attributes.position;
        const landRadius = globeRadius + 0.018;
        for (let i = 0; i < position.count; i++) {
          const lon = position.getX(i);
          const lat = position.getY(i);
          const vertex = convertLatLonToXYZ(lat, lon, landRadius);
          position.setXYZ(i, vertex.x, vertex.y, vertex.z);
        }
        position.needsUpdate = true;
        geometry.computeVertexNormals();

        const mesh = new THREE.Mesh(geometry, landMaterial);
        mesh.frustumCulled = false;
        landGroup.add(mesh);
      };

      const loadLandPolygons = async () => {
        try {
          const response = await fetch(
            'https://raw.githubusercontent.com/datasets/geo-boundaries-world-110m/master/countries.geojson'
          );
          if (!response.ok) throw new Error('Failed to load land GeoJSON');
          const data = await response.json();
          const features = Array.isArray(data.features) ? data.features : [];
          features.forEach((feature) => {
            const geometry = feature && feature.geometry;
            if (!geometry) return;
            if (geometry.type === 'Polygon') {
              buildPolygon(geometry.coordinates);
            } else if (geometry.type === 'MultiPolygon') {
              geometry.coordinates.forEach(buildPolygon);
            }
          });
        } catch (error) {
          console.error('Unable to build land polygons', error);
        }
      };

      loadLandPolygons();

      const markerMeshes = [];
      let hoveredMarker = null;
      const raycaster = new THREE.Raycaster();
      const pointer = new THREE.Vector2();

      const createMarker = (activity) => {
        const { lat, lon, name, id } = activity;
        const position = convertLatLonToXYZ(lat, lon, globeRadius + 0.02);
        const material = new THREE.MeshStandardMaterial({
          color: new THREE.Color('#636B2F'),
          emissive: new THREE.Color('#636B2F'),
          emissiveIntensity: 0.08,
          transparent: true,
          opacity: 0.7,
          roughness: 0.45,
          metalness: 0.08,
        });
        const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.08, 28, 28), material);
        mesh.position.copy(position);
        mesh.lookAt(new THREE.Vector3(0, 0, 0));
        mesh.userData = {
          id,
          name,
          lat,
          lon,
          baseEmissive: material.emissiveIntensity,
          baseOpacity: material.opacity,
        };
        markerGroup.add(mesh);
        markerMeshes.push(mesh);
      };

      const resetHover = () => {
        if (!hoveredMarker) return;
        hoveredMarker.material.emissiveIntensity = hoveredMarker.userData.baseEmissive;
        hoveredMarker.material.opacity = hoveredMarker.userData.baseOpacity;
        hoveredMarker.scale.set(1, 1, 1);
        hoveredMarker = null;
        tooltip.hidden = true;
      };

      const setHover = (marker, event) => {
        if (hoveredMarker !== marker) {
          resetHover();
          hoveredMarker = marker;
          marker.material.emissiveIntensity = 0.35;
          marker.material.opacity = 0.95;
          marker.scale.set(1.45, 1.45, 1.45);
          tooltip.textContent = marker.userData.name || 'Activity';
          tooltip.hidden = false;
        }
        const rect = globeRenderer.domElement.getBoundingClientRect();
        tooltip.style.left = `${event.clientX - rect.left + 12}px`;
        tooltip.style.top = `${event.clientY - rect.top - 12}px`;
      };

      const onMarkerClick = (marker) => {
        const { id, lat, lon } = marker.userData;
        const url = `https://www.google.com/maps/search/?api=1&query=${lat.toFixed(5)},${lon.toFixed(5)}`;
        window.open(url, '_blank', 'noopener');
        if (typeof window.onGlobeMarkerClick === 'function') {
          window.onGlobeMarkerClick({ id, lat, lon });
        }
      };

      const updatePointerFromEvent = (event) => {
        const rect = globeRenderer.domElement.getBoundingClientRect();
        pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      };

      const handlePointerMove = (event) => {
        updatePointerFromEvent(event);
        raycaster.setFromCamera(pointer, globeCamera);
        const intersects = raycaster.intersectObjects(markerMeshes);
        if (intersects.length > 0) {
          setHover(intersects[0].object, event);
        } else {
          resetHover();
        }
      };

      const handlePointerLeave = () => {
        resetHover();
      };

      const handlePointerClick = (event) => {
        updatePointerFromEvent(event);
        raycaster.setFromCamera(pointer, globeCamera);
        const intersects = raycaster.intersectObjects(markerMeshes);
        if (intersects.length > 0) {
          const marker = intersects[0].object;
          onMarkerClick(marker);
        }
      };

      globeRenderer.domElement.addEventListener('pointermove', handlePointerMove);
      globeRenderer.domElement.addEventListener('pointerleave', handlePointerLeave);
      globeRenderer.domElement.addEventListener('click', handlePointerClick);

      const resizeGlobe = () => {
        const { clientWidth, clientHeight } = stage;
        if (!clientWidth || !clientHeight) return;
        globeRenderer.setSize(clientWidth, clientHeight, false);
        globeCamera.aspect = clientWidth / clientHeight;
        globeCamera.updateProjectionMatrix();
      };

      const loadActivities = async () => {
        try {
          const response = await fetch('assets/activities.json');
          if (!response.ok) throw new Error('Failed to load activities');
          const data = await response.json();
          resetHover();
          markerGroup.clear();
          markerMeshes.length = 0;
          (data.activities || []).forEach(createMarker);
        } catch (error) {
          console.warn(error);
        }
      };

      const animateGlobe = () => {
        requestAnimationFrame(animateGlobe);
        if (!userIsInteracting) {
          globeGroup.rotation.y += 0.00035;
        }
        controls.update();
        globeRenderer.render(globeScene, globeCamera);
      };

      resizeGlobe();
      window.addEventListener('resize', resizeGlobe);
      loadActivities();
      animateGlobe();

      const canvas = document.createElement('canvas');
      canvas.id = 'dna-helix';
      canvas.setAttribute('aria-hidden', 'true');
      document.body.appendChild(canvas);

      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
      renderer.setClearColor(0x000000, 0);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
      camera.position.set(0, 0, 16);
      camera.lookAt(0, 0, 0);

      const helixGroup = new THREE.Group();
      scene.add(helixGroup);

      const oliveColor = new THREE.Color('#636B2F');
      const baseOpacity = 0.5;

      const dotTexture = (() => {
        const size = 128;
        const texCanvas = document.createElement('canvas');
        texCanvas.width = texCanvas.height = size;
        const ctx = texCanvas.getContext('2d');
        const gradient = ctx.createRadialGradient(
          size / 2,
          size / 2,
          size * 0.1,
          size / 2,
          size / 2,
          size * 0.5
        );
        gradient.addColorStop(0, 'rgba(99,107,47,0.5)');
        gradient.addColorStop(1, 'rgba(99,107,47,0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, size, size);
        const texture = new THREE.CanvasTexture(texCanvas);
        texture.wrapS = texture.wrapT = THREE.ClampToEdgeWrapping;
        return texture;
      })();

      const segments = 900;
      const turns = 1.5;
      const helixHeight = 12.5;
      const helixRadius = 2.6;
      const rungInterval = 12;

      const strandPositions = [];
      const rungPositions = [];
      const pointPositions = [];
      const ambientPositions = [];
      const clusterPositions = [];
      const clusterLinkPositions = [];

      for (let i = 0; i <= segments; i++) {
        const progress = i / segments;
        const angle = progress * Math.PI * 2 * turns;
        const y = (progress - 0.5) * helixHeight;

        const baseX = Math.cos(angle) * helixRadius;
        const baseZ = Math.sin(angle) * helixRadius;
        const jitter = (Math.random() - 0.5) * 0.22;
        const x1 = baseX + jitter;
        const z1 = baseZ + jitter * 0.4;
        const x2 = -baseX + (Math.random() - 0.5) * 0.22;
        const z2 = -baseZ + (Math.random() - 0.5) * 0.22;

        pointPositions.push(x1, y, z1, x2, y, z2);

        if (i < segments) {
          const nextProgress = (i + 1) / segments;
          const nextAngle = nextProgress * Math.PI * 2 * turns;
          const nextY = (nextProgress - 0.5) * helixHeight;
          const nextBaseX = Math.cos(nextAngle) * helixRadius;
          const nextBaseZ = Math.sin(nextAngle) * helixRadius;
          const nextJitter = (Math.random() - 0.5) * 0.22;
          const nx1 = nextBaseX + nextJitter;
          const nz1 = nextBaseZ + nextJitter * 0.4;
          const nx2 = -nextBaseX + (Math.random() - 0.5) * 0.22;
          const nz2 = -nextBaseZ + (Math.random() - 0.5) * 0.22;

          strandPositions.push(x1, y, z1, nx1, nextY, nz1);
          strandPositions.push(x2, y, z2, nx2, nextY, nz2);
        }

        if (i % rungInterval === 0) {
          rungPositions.push(x1, y, z1, x2, y, z2);
        }

        if (i % 7 === 0) {
          const clusterSize = 16;
          for (let c = 0; c < clusterSize; c++) {
            const offsetRadius = helixRadius * (0.45 + Math.random() * 0.75);
            const offsetAngle = angle + (Math.random() - 0.5) * 1.1;
            const cx = Math.cos(offsetAngle) * offsetRadius + (Math.random() - 0.5) * 1.2;
            const cy = y + (Math.random() - 0.5) * 1.4;
            const cz = Math.sin(offsetAngle) * offsetRadius + (Math.random() - 0.5) * 1.2;

            clusterPositions.push(cx, cy, cz);
            clusterLinkPositions.push(cx, cy, cz, x1, y, z1);
          }
        }
      }

      const ambientCount = 2600;
      for (let i = 0; i < ambientCount; i++) {
        const spread = helixRadius * (0.9 + Math.random() * 1.1);
        const theta = Math.random() * Math.PI * 2 * turns;
        const y = (Math.random() - 0.5) * helixHeight * 1.1;
        const x = Math.cos(theta) * spread + (Math.random() - 0.5) * 0.7;
        const z = Math.sin(theta) * spread + (Math.random() - 0.5) * 0.7;
        ambientPositions.push(x, y, z);
      }

      const pointGeometry = new THREE.BufferGeometry();
      pointGeometry.setAttribute(
        'position',
        new THREE.Float32BufferAttribute(pointPositions, 3)
      );

      const strandGeometry = new THREE.BufferGeometry();
      strandGeometry.setAttribute(
        'position',
        new THREE.Float32BufferAttribute(strandPositions, 3)
      );

      const rungGeometry = new THREE.BufferGeometry();
      rungGeometry.setAttribute(
        'position',
        new THREE.Float32BufferAttribute(rungPositions, 3)
      );

      const ambientGeometry = new THREE.BufferGeometry();
      ambientGeometry.setAttribute(
        'position',
        new THREE.Float32BufferAttribute(ambientPositions, 3)
      );

      const clusterGeometry = new THREE.BufferGeometry();
      clusterGeometry.setAttribute(
        'position',
        new THREE.Float32BufferAttribute(clusterPositions, 3)
      );

      const clusterLinkGeometry = new THREE.BufferGeometry();
      clusterLinkGeometry.setAttribute(
        'position',
        new THREE.Float32BufferAttribute(clusterLinkPositions, 3)
      );

      const pointsMaterial = new THREE.PointsMaterial({
        map: dotTexture,
        alphaMap: dotTexture,
        color: oliveColor,
        size: 0.32,
        transparent: true,
        opacity: baseOpacity,
        blending: THREE.NormalBlending,
        depthWrite: false,
        sizeAttenuation: true,
      });

      const strandMaterial = new THREE.LineBasicMaterial({
        color: oliveColor,
        transparent: true,
        opacity: baseOpacity,
        blending: THREE.NormalBlending,
        depthWrite: false,
      });

      const rungMaterial = strandMaterial.clone();

      const ambientMaterial = new THREE.PointsMaterial({
        map: dotTexture,
        alphaMap: dotTexture,
        color: oliveColor,
        size: 0.22,
        transparent: true,
        opacity: baseOpacity,
        blending: THREE.NormalBlending,
        depthWrite: false,
        sizeAttenuation: true,
      });

      const clusterMaterial = new THREE.PointsMaterial({
        map: dotTexture,
        alphaMap: dotTexture,
        color: oliveColor,
        size: 0.28,
        transparent: true,
        opacity: baseOpacity,
        blending: THREE.NormalBlending,
        depthWrite: false,
        sizeAttenuation: true,
      });

      const clusterLinkMaterial = new THREE.LineBasicMaterial({
        color: oliveColor,
        transparent: true,
        opacity: baseOpacity,
        blending: THREE.NormalBlending,
        depthWrite: false,
      });

      helixGroup.add(new THREE.Points(pointGeometry, pointsMaterial));
      helixGroup.add(new THREE.LineSegments(strandGeometry, strandMaterial));
      helixGroup.add(new THREE.LineSegments(rungGeometry, rungMaterial));
      helixGroup.add(new THREE.Points(ambientGeometry, ambientMaterial));
      helixGroup.add(new THREE.Points(clusterGeometry, clusterMaterial));
      helixGroup.add(new THREE.LineSegments(clusterLinkGeometry, clusterLinkMaterial));

      helixGroup.scale.set(1.8, 0.45, 0.55);
      const baseRotation = new THREE.Euler(Math.PI / 5, Math.PI / 4, -Math.PI / 4);
      helixGroup.rotation.copy(baseRotation);

      const resizeRenderer = () => {
        const width = canvas.clientWidth;
        const height = canvas.clientHeight;
        if (!width || !height) return;
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(width, height, false);
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
      };

      window.addEventListener('resize', resizeRenderer);
      resizeRenderer();

      const maxScroll = () => document.body.scrollHeight - window.innerHeight;
      const baseRotationY = helixGroup.rotation.y;

      const updateScrollEffects = () => {
        const ratio = maxScroll() > 0 ? window.scrollY / maxScroll() : 0;
        const rotationRange = 0.45;
        helixGroup.rotation.y = baseRotationY + THREE.MathUtils.lerp(-rotationRange, rotationRange, ratio);
        const cameraTilt = THREE.MathUtils.lerp(-0.05, 0.04, ratio);
        camera.rotation.x = cameraTilt;
        canvas.style.opacity = (0.3 + (1 - ratio) * 0.15).toFixed(2);
      };

      window.addEventListener('scroll', updateScrollEffects, { passive: true });
      updateScrollEffects();

      const animate = () => {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
      };

      animate();
    </script>
  </body>
</html>
