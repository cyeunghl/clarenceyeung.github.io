<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Clarence Yeung · Portfolio</title>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <!-- Layout Wrapper -->
    <main class="page">
      <!-- Visual Column with Three.js Globe -->
      <section class="visual-column" aria-labelledby="visual-title">
        <div class="visual-container" role="presentation">
          <span class="sr-only" id="visual-title">Interactive globe with activity highlights</span>
          <div class="visual-globe" aria-hidden="true"></div>
        </div>
      </section>

      <!-- Content Column -->
      <section class="content-column">
        <header class="page-header">
          <div class="header-inner">
            <div class="hero-portrait" aria-hidden="true">
              <span>Portrait</span>
            </div>
            <h1>Clarence Yeung</h1>
          </div>
        </header>

        <!-- About Section -->
        <section class="content-section" id="about">
          <h2>About Me</h2>
          <nav aria-label="Primary links" class="about-links">
            <a href="https://www.linkedin.com" target="_blank" rel="noopener">LinkedIn</a>
            <span aria-hidden="true">·</span>
            <a href="https://scholar.google.com" target="_blank" rel="noopener"
              >Google Scholar</a
            >
            <span aria-hidden="true">·</span>
            <a href="https://github.com" target="_blank" rel="noopener">GitHub</a>
          </nav>
        </section>

        <!-- Projects Section -->
        <section class="content-section" id="projects">
          <h2>Projects</h2>
          <ul class="project-list">
            <li>
              <h3>Motion Atlas</h3>
              <p>
                A generative study that maps cycling telemetry into kinetic sculptures, pairing
                physics with visual storytelling.
              </p>
            </li>
            <li>
              <h3>Helix Studio</h3>
              <p>
                Interactive DNA narratives that invite visitors to manipulate molecular forms through
                touch and gesture.
              </p>
            </li>
            <li>
              <h3>Living Recipes</h3>
              <p>
                Culinary experiments documented as responsive micro-sites, highlighting craft and
                sensory memory.
              </p>
            </li>
          </ul>
        </section>

        <!-- Contact Section -->
        <section class="content-section" id="contact">
          <h2>Contact</h2>
          <p>
            Reach out for collaborations, research inquiries, or to swap ride routes:
            <a href="mailto:hello@clarenceyeung.com">hello@clarenceyeung.com</a>
          </p>
          <p class="contact-links">
            <a href="https://www.linkedin.com" target="_blank" rel="noopener">LinkedIn</a>
            <span aria-hidden="true">·</span>
            <a href="https://github.com" target="_blank" rel="noopener">GitHub</a>
            <span aria-hidden="true">·</span>
            <a href="https://scholar.google.com" target="_blank" rel="noopener">Google Scholar</a>
            <span aria-hidden="true">·</span>
            <a href="https://clarenceyeung.substack.com" target="_blank" rel="noopener">Substack</a>
          </p>
        </section>
      </section>
    </main>

    <script type="module">
      import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.158/build/three.module.js';
      import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.158/examples/jsm/controls/OrbitControls.js';
      import { feature } from 'https://cdn.jsdelivr.net/npm/topojson-client@3/+esm';
      import { geoGraticule10 } from 'https://cdn.jsdelivr.net/npm/d3-geo@3/+esm';

      const container = document.querySelector('.visual-globe');
      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.setClearColor(0x000000, 0);
      container.appendChild(renderer.domElement);

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(40, 1, 0.1, 100);
      camera.position.set(0, 0, 6);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.enablePan = false;
      controls.minDistance = 3.5;
      controls.maxDistance = 8;
      controls.autoRotate = false;
      controls.enableZoom = true;
      controls.target.set(0, 0, 0);
      controls.update();

      const ambientLight = new THREE.AmbientLight(0x667799, 0.4);
      const directionalLight = new THREE.DirectionalLight(0xbfd1ff, 0.75);
      directionalLight.position.set(5, 4, 3);
      scene.add(ambientLight, directionalLight);

      const globeGroup = new THREE.Group();
      scene.add(globeGroup);

      const RADIUS = 2.2;
      const globeMaterial = new THREE.MeshPhongMaterial({
        color: 0x0a1325,
        emissive: 0x05070f,
        shininess: 18,
        transparent: true,
        opacity: 0.92,
      });
      const globeMesh = new THREE.Mesh(new THREE.SphereGeometry(RADIUS, 96, 96), globeMaterial);
      globeGroup.add(globeMesh);

      const outlineGroup = new THREE.Group();
      globeGroup.add(outlineGroup);

      const graticuleGroup = new THREE.Group();
      globeGroup.add(graticuleGroup);

      const lineMaterial = new THREE.LineBasicMaterial({ color: 0xf2f5ff, transparent: true, opacity: 0.55 });
      const graticuleMaterial = new THREE.LineBasicMaterial({ color: 0x223a5c, transparent: true, opacity: 0.4 });

      const latLonToVector3 = (lat, lon, radius = RADIUS + 0.002) => {
        // Latitude/longitude (in degrees) mapped onto the sphere surface using spherical coordinates.
        const phi = THREE.MathUtils.degToRad(90 - lat);
        const theta = THREE.MathUtils.degToRad(lon + 180);
        const x = -radius * Math.sin(phi) * Math.cos(theta);
        const z = radius * Math.sin(phi) * Math.sin(theta);
        const y = radius * Math.cos(phi);
        return new THREE.Vector3(x, y, z);
      };

      const addLineFromCoords = (coords) => {
        const points = coords.map(([lon, lat]) => latLonToVector3(lat, lon));
        if (points.length < 2) return;
        const first = points[0];
        const last = points[points.length - 1];
        if (!first.equals(last)) {
          points.push(first.clone());
        }
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.LineLoop(geometry, lineMaterial);
        outlineGroup.add(line);
      };

      const addGlowingPoint = (lat, lon) => {
        const position = latLonToVector3(lat, lon, RADIUS + 0.04);
        const geometry = new THREE.SphereGeometry(0.045, 16, 16);
        const material = new THREE.MeshBasicMaterial({ color: 0x7fd3ff });
        const point = new THREE.Mesh(geometry, material);
        point.position.copy(position);
        const glow = new THREE.Mesh(
          new THREE.SphereGeometry(0.09, 16, 16),
          new THREE.MeshBasicMaterial({ color: 0x7fd3ff, transparent: true, opacity: 0.28 })
        );
        glow.position.copy(position);
        globeGroup.add(glow);
        globeGroup.add(point);
      };

      const addGraticule = () => {
        const grid = geoGraticule10();
        const convertLine = (lineCoords) => {
          const points = lineCoords.map(([lon, lat]) => latLonToVector3(lat, lon, RADIUS + 0.001));
          if (points.length < 2) return;
          const geometry = new THREE.BufferGeometry().setFromPoints(points);
          graticuleGroup.add(new THREE.Line(geometry, graticuleMaterial));
        };
        grid.coordinates.forEach(convertLine);
      };

      const resize = () => {
        const { clientWidth, clientHeight } = container;
        const width = clientWidth;
        const height = clientHeight;
        if (width === 0 || height === 0) return;
        renderer.setSize(width, height, false);
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
      };

      const animate = () => {
        requestAnimationFrame(animate);
        globeGroup.rotation.y += 0.0009;
        controls.update();
        renderer.render(scene, camera);
      };

      const loadWorldData = async () => {
        const response = await fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json');
        const topoJson = await response.json();
        // Convert TopoJSON from World Atlas into GeoJSON features for each country, then
        // turn each polygon into a closed Three.js line so outlines hug the sphere.
        const worldGeo = feature(topoJson, topoJson.objects.countries);
        worldGeo.features.forEach((country) => {
          if (country.geometry.type === 'Polygon') {
            country.geometry.coordinates.forEach(addLineFromCoords);
          } else if (country.geometry.type === 'MultiPolygon') {
            country.geometry.coordinates.forEach((polygon) => polygon.forEach(addLineFromCoords));
          }
        });
      };

      const loadActivityPoints = async () => {
        const response = await fetch('assets/mock-strava.json');
        const data = await response.json();
        // Replace the JSON file or adjust each activity's coordinates to spotlight your own data
        // (for example, favourite recipes, travel spots, or studio locations).
        data.activities.forEach((activity) => {
          const [lat, lon] = activity.coordinates;
          addGlowingPoint(lat, lon);
        });
      };

      const init = async () => {
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        resize();
        window.addEventListener('resize', resize);
        addGraticule();
        await Promise.all([loadWorldData(), loadActivityPoints()]);
        animate();
      };

      init().catch((error) => console.error('Globe initialisation failed:', error));
    </script>
  </body>
</html>
