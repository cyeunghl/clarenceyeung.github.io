<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Clarence Yeung · Lab &amp; Larder</title>
    <link rel="stylesheet" href="style.css" />
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.158/build/three.module.js",
          "three/examples/jsm/controls/OrbitControls.js": "https://cdn.jsdelivr.net/npm/three@0.158/examples/jsm/controls/OrbitControls.js"
        }
      }
    </script>
  </head>
  <body>
    <main class="recipe-layout">
      <section class="image-column" aria-label="Cookbook inspired portrait and globe visualization">
        <div class="image-panel">
          <div class="image-panel__overlay">
            <div class="portrait-frame" aria-hidden="true">
              <span>Portrait Placeholder</span>
            </div>
            <p class="image-note">Clarence Yeung · Lab &amp; Larder</p>
          </div>
          <div class="globe-wrapper">
            <div class="globe-stage" id="globe-stage" role="presentation" aria-hidden="true"></div>
            <div
              class="globe-tooltip"
              id="globe-tooltip"
              role="status"
              aria-live="polite"
              hidden
            ></div>
            <p class="globe-caption">Strava JSON routes plated as mustard markers.</p>
          </div>
        </div>
      </section>

      <section class="text-column">
        <header class="title-block">
          <p class="title-block__label">Lab &amp; Larder Recipe Card</p>
          <h1 class="recipe-title">Clarence Yeung</h1>
          <p class="servings-info">Serves curious collaborators &amp; hungry cyclists</p>
          <p class="intro-paragraph">
            Scientist by training, cook by curiosity. I stir together oncology research, fermentation
            experiments, and long rides across Bay Area ridgelines—always in pursuit of approachable precision.
          </p>
          <p class="attribution">Currently crafting at Hexagon Bio · Toronto roots, California kitchen.</p>
        </header>

        <nav class="links-list" aria-label="Personal links">
          <a href="https://www.linkedin.com/in/clarence-yeung-8454237a/" target="_blank" rel="noopener">LinkedIn</a>
          <a href="https://github.com/cyeunghl" target="_blank" rel="noopener">GitHub</a>
          <a href="https://scholar.google.com/citations?user=sMj4W4EAAAAJ&hl=en&oi=ao" target="_blank" rel="noopener">Google Scholar</a>
          <a href="https://clarenceyeung.substack.com" target="_blank" rel="noopener">Substack</a>
        </nav>

        <div class="divider" role="presentation"></div>

        <section class="content-columns" aria-labelledby="ingredients-heading">
          <div class="column column--ingredients">
            <h2 id="ingredients-heading">Ingredients</h2>
            <ul class="ingredients-list">
              <li><span class="quantity">1</span><span class="item">Genomics &amp; systems biology toolkit</span></li>
              <li><span class="quantity">2</span><span class="item">Scoops of computational modeling &amp; data viz</span></li>
              <li><span class="quantity">3</span><span class="item">Pinches of mentorship &amp; collaborative lab culture</span></li>
              <li><span class="quantity">A dash</span><span class="item">Fermentation, lamination &amp; broth experiments</span></li>
            </ul>
            <p class="footnote">Pictured portrait to be plated soon.</p>
          </div>
          <div class="column column--instructions">
            <h2>Instructions</h2>
            <p><strong>Lead</strong> oncology discovery at Hexagon Bio, translating genomic whispers into candidate medicines.</p>
            <p><strong>Weave</strong> research notes into essays that read like tasting menus—precision framed with warmth.</p>
            <p><strong>Season</strong> community gatherings with pop-up dinners and science salons that invite conversation.</p>
            <p><strong>Ride</strong> coastal switchbacks, capture the data, and fold each climb into visual stories below.</p>
          </div>
        </section>

        <section class="strava-card" aria-labelledby="strava-heading">
          <div class="strava-card__header">
            <h2 id="strava-heading">Ride Pantry</h2>
            <p class="strava-card__subtitle">Heat, routes, and seasonal stats direct from Strava JSON.</p>
          </div>
          <div class="strava-card__body">
            <div class="strava-summary" id="ride-summary" aria-live="polite">Loading seasonal stats…</div>
            <figure class="strava-heatmap">
              <canvas id="ride-heatmap" width="360" height="220" aria-label="Heatmap of logged rides"></canvas>
              <figcaption>Global activity heatmap rendered in neutral stock.</figcaption>
            </figure>
            <div class="strava-list">
              <h3>Featured Rides</h3>
              <ol id="ride-feature-list" class="feature-list" aria-live="polite">
                <li>Awaiting route cards…</li>
              </ol>
            </div>
          </div>
        </section>

        <section class="contact-card" aria-labelledby="contact-heading">
          <h2 id="contact-heading">Say Hello</h2>
          <p>
            Write to <a href="mailto:clarencehlyeung@gmail.com">clarencehlyeung@gmail.com</a> for collaborations,
            ride suggestions, or a favourite family recipe.
          </p>
          <p class="contact-note">Always open to co-authoring papers, menus, or mountain switchbacks.</p>
        </section>
      </section>
    </main>

    <script type="module">
      import * as THREE from 'three';
      import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

      /* ---------------------------------------- */
      /* Minimal Globe Setup                      */
      /* ---------------------------------------- */
      const stage = document.getElementById('globe-stage');
      const tooltip = document.getElementById('globe-tooltip');

      const globeScene = new THREE.Scene();
      const globeCamera = new THREE.PerspectiveCamera(40, 1, 0.1, 1000);
      const globeRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      globeRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      globeRenderer.outputColorSpace = THREE.SRGBColorSpace;
      globeRenderer.toneMapping = THREE.ACESFilmicToneMapping;
      globeRenderer.toneMappingExposure = 1.05;
      globeRenderer.setClearColor(0x000000, 0);
      stage.appendChild(globeRenderer.domElement);
      globeRenderer.domElement.style.cursor = 'grab';
      globeRenderer.domElement.style.outline = 'none';
      globeRenderer.domElement.addEventListener('pointerdown', () => {
        globeRenderer.domElement.style.cursor = 'grabbing';
      });
      ['pointerup', 'pointerleave'].forEach((evt) => {
        globeRenderer.domElement.addEventListener(evt, () => {
          globeRenderer.domElement.style.cursor = 'grab';
        });
      });

      const globeGroup = new THREE.Group();
      globeScene.add(globeGroup);

      const globeRadius = 3.2;

      const oceanMaterial = new THREE.MeshLambertMaterial({ color: '#f1ede5' });
      const oceanMesh = new THREE.Mesh(new THREE.SphereGeometry(globeRadius, 128, 128), oceanMaterial);
      globeGroup.add(oceanMesh);

      const landMaterial = new THREE.MeshLambertMaterial({
        color: '#cbb79f',
        transparent: true,
        opacity: 0.94,
        side: THREE.DoubleSide,
      });
      const landGroup = new THREE.Group();
      globeGroup.add(landGroup);

      const markerGroup = new THREE.Group();
      globeGroup.add(markerGroup);

      const ambientLight = new THREE.AmbientLight(0xfefbf6, 0.62);
      globeScene.add(ambientLight);
      const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
      sunLight.position.set(-6.5, 7.5, 6.5);
      globeScene.add(sunLight);

      globeCamera.position.set(0, 0, globeRadius * 4.2);

      const controls = new OrbitControls(globeCamera, globeRenderer.domElement);
      controls.enablePan = false;
      controls.enableDamping = true;
      controls.dampingFactor = 0.08;
      controls.enableZoom = true;
      controls.minDistance = globeRadius * 1.6;
      controls.maxDistance = globeRadius * 4.8;

      let userIsInteracting = false;
      controls.addEventListener('start', () => {
        userIsInteracting = true;
      });
      controls.addEventListener('end', () => {
        userIsInteracting = false;
      });

      globeGroup.rotation.x = THREE.MathUtils.degToRad(18);

      const convertLatLonToXYZ = (lat, lon, radius) => {
        const phi = THREE.MathUtils.degToRad(90 - lat);
        const theta = THREE.MathUtils.degToRad(lon + 180);
        const x = -radius * Math.sin(phi) * Math.cos(theta);
        const z = radius * Math.sin(phi) * Math.sin(theta);
        const y = radius * Math.cos(phi);
        return new THREE.Vector3(x, y, z);
      };

      const buildPolygon = (rings) => {
        if (!Array.isArray(rings) || rings.length === 0) return;
        const [outer, ...holes] = rings;
        if (!outer || outer.length < 3) return;

        const shape = new THREE.Shape();
        outer.forEach(([lon, lat], index) => {
          if (index === 0) {
            shape.moveTo(lon, lat);
          } else {
            shape.lineTo(lon, lat);
          }
        });

        const holePaths = holes
          .filter((hole) => Array.isArray(hole) && hole.length >= 3)
          .map((hole) => {
            const path = new THREE.Path();
            hole.forEach(([lon, lat], index) => {
              if (index === 0) {
                path.moveTo(lon, lat);
              } else {
                path.lineTo(lon, lat);
              }
            });
            return path;
          });

        const geometry = new THREE.ShapeGeometry(shape, holePaths);
        const position = geometry.attributes.position;
        const landRadius = globeRadius + 0.01;
        for (let i = 0; i < position.count; i++) {
          const lon = position.getX(i);
          const lat = position.getY(i);
          const vertex = convertLatLonToXYZ(lat, lon, landRadius);
          position.setXYZ(i, vertex.x, vertex.y, vertex.z);
        }
        position.needsUpdate = true;
        geometry.computeVertexNormals();

        const mesh = new THREE.Mesh(geometry, landMaterial);
        landGroup.add(mesh);
      };

      const loadLandPolygons = async () => {
        try {
          const response = await fetch(
            'https://raw.githubusercontent.com/datasets/geo-boundaries-world-110m/master/countries.geojson'
          );
          if (!response.ok) throw new Error('Failed to load land GeoJSON');
          const data = await response.json();
          const features = Array.isArray(data.features) ? data.features : [];
          features.forEach((feature) => {
            const geometry = feature && feature.geometry;
            if (!geometry) return;
            if (geometry.type === 'Polygon') {
              buildPolygon(geometry.coordinates);
            } else if (geometry.type === 'MultiPolygon') {
              geometry.coordinates.forEach(buildPolygon);
            }
          });
        } catch (error) {
          console.error('Unable to build land polygons', error);
        }
      };

      loadLandPolygons();

      const markerMeshes = [];
      let hoveredMarker = null;
      const raycaster = new THREE.Raycaster();
      const pointer = new THREE.Vector2();

      const createMarker = (activity) => {
        const { lat, lon, name, id } = activity;
        const position = convertLatLonToXYZ(lat, lon, globeRadius + 0.02);
        const material = new THREE.MeshStandardMaterial({
          color: new THREE.Color('#C18E57'),
          emissive: new THREE.Color('#C18E57'),
          emissiveIntensity: 0.12,
          transparent: true,
          opacity: 0.7,
          roughness: 0.45,
          metalness: 0.08,
        });
        const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.08, 28, 28), material);
        mesh.position.copy(position);
        mesh.lookAt(new THREE.Vector3(0, 0, 0));
        mesh.userData = {
          id,
          name,
          lat,
          lon,
          baseEmissive: material.emissiveIntensity,
          baseOpacity: material.opacity,
        };
        markerGroup.add(mesh);
        markerMeshes.push(mesh);
      };

      const resetHover = () => {
        if (!hoveredMarker) return;
        hoveredMarker.material.emissiveIntensity = hoveredMarker.userData.baseEmissive;
        hoveredMarker.material.opacity = hoveredMarker.userData.baseOpacity;
        hoveredMarker.scale.set(1, 1, 1);
        hoveredMarker = null;
        tooltip.hidden = true;
      };

      const setHover = (marker, event) => {
        if (hoveredMarker !== marker) {
          resetHover();
          hoveredMarker = marker;
          marker.material.emissiveIntensity = 0.42;
          marker.material.opacity = 0.98;
          marker.scale.set(1.45, 1.45, 1.45);
          tooltip.textContent = marker.userData.name || 'Activity';
          tooltip.hidden = false;
        }
        const rect = globeRenderer.domElement.getBoundingClientRect();
        tooltip.style.left = `${event.clientX - rect.left + 12}px`;
        tooltip.style.top = `${event.clientY - rect.top - 12}px`;
      };

      const onMarkerClick = (marker) => {
        const { id, lat, lon } = marker.userData;
        const url = `https://www.google.com/maps/search/?api=1&query=${lat.toFixed(5)},${lon.toFixed(5)}`;
        window.open(url, '_blank', 'noopener');
        if (typeof window.onGlobeMarkerClick === 'function') {
          window.onGlobeMarkerClick({ id, lat, lon });
        }
      };

      const updatePointerFromEvent = (event) => {
        const rect = globeRenderer.domElement.getBoundingClientRect();
        pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      };

      const handlePointerMove = (event) => {
        updatePointerFromEvent(event);
        raycaster.setFromCamera(pointer, globeCamera);
        const intersects = raycaster.intersectObjects(markerMeshes);
        if (intersects.length > 0) {
          setHover(intersects[0].object, event);
        } else {
          resetHover();
        }
      };

      const handlePointerLeave = () => {
        resetHover();
      };

      const handlePointerClick = (event) => {
        updatePointerFromEvent(event);
        raycaster.setFromCamera(pointer, globeCamera);
        const intersects = raycaster.intersectObjects(markerMeshes);
        if (intersects.length > 0) {
          const marker = intersects[0].object;
          onMarkerClick(marker);
        }
      };

      globeRenderer.domElement.addEventListener('pointermove', handlePointerMove);
      globeRenderer.domElement.addEventListener('pointerleave', handlePointerLeave);
      globeRenderer.domElement.addEventListener('click', handlePointerClick);

      const resizeGlobe = () => {
        const { clientWidth, clientHeight } = stage;
        if (!clientWidth || !clientHeight) return;
        globeRenderer.setSize(clientWidth, clientHeight, false);
        globeCamera.aspect = clientWidth / clientHeight;
        globeCamera.updateProjectionMatrix();
      };

      const generateActivityId = () => {
        if (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function') {
          return crypto.randomUUID();
        }
        return `ride-${Math.random().toString(36).slice(2, 10)}`;
      };

      const normalizeActivity = (activity) => {
        if (!activity || typeof activity !== 'object') return null;
        const getValue = (keys, fallback = null) => {
          for (const key of keys) {
            const value = activity[key];
            if (value !== undefined && value !== null && value !== '') {
              return value;
            }
          }
          return fallback;
        };

        const parseCoordinate = (value) => {
          if (typeof value === 'number') return value;
          if (typeof value !== 'string') return null;
          const match = value.match(/-?\d+\.\d+/);
          if (!match) return null;
          return parseFloat(match[0]);
        };

        const lat = parseCoordinate(getValue(['lat', 'activities.lat']));
        const lon = parseCoordinate(getValue(['lon', 'activities.lon']));
        if (lat === null || lon === null) return null;

        const id = getValue(['id', 'activities.id']);
        const resolvedId = id ?? generateActivityId();
        const name = getValue(['name', 'activities.name'], 'Ride');
        const type = getValue(['type', 'activities.type'], 'Ride');
        const distance = Number.parseFloat(getValue(['distance', 'activities.distance'], 0)) || 0;
        const startDate = getValue(['start_date', 'activities.start_date'], null);

        return { id: resolvedId, name, type, distance, startDate, lat, lon };
      };

      const rideSummary = document.getElementById('ride-summary');
      const rideFeatureList = document.getElementById('ride-feature-list');
      const heatmapCanvas = document.getElementById('ride-heatmap');

      const formatDistance = (meters) => {
        const kilometers = meters / 1000;
        if (kilometers >= 100) return `${kilometers.toFixed(0)} km`;
        if (kilometers >= 10) return `${kilometers.toFixed(1)} km`;
        return `${kilometers.toFixed(2)} km`;
      };

      const formatDate = (isoString) => {
        if (!isoString) return 'Date TBC';
        const date = new Date(isoString);
        if (Number.isNaN(date.getTime())) return 'Date TBC';
        return date.toLocaleDateString(undefined, { year: 'numeric', month: 'short', day: 'numeric' });
      };

      const renderSummary = (activities) => {
        if (!Array.isArray(activities) || activities.length === 0) {
          rideSummary.textContent = 'No routes in the pantry yet. Drop in a Strava JSON to season this section.';
          rideFeatureList.innerHTML = '<li>Upload rides to see featured cards.</li>';
          return;
        }

        const rides = activities.filter((item) => (item.type || '').toLowerCase().includes('ride'));
        const runs = activities.filter((item) => (item.type || '').toLowerCase().includes('run'));

        const totalDistance = activities.reduce((sum, item) => sum + (item.distance || 0), 0);
        const maxRide = rides.reduce((acc, item) => (item.distance > (acc?.distance ?? 0) ? item : acc), null);

        const now = new Date();
        const twelveMonthsAgo = new Date(now.getFullYear() - 1, now.getMonth(), now.getDate());
        const recentActivities = activities.filter((item) => {
          if (!item.startDate) return false;
          const date = new Date(item.startDate);
          return date >= twelveMonthsAgo && date <= now;
        });
        const recentDistance = recentActivities.reduce((sum, item) => sum + (item.distance || 0), 0);

        rideSummary.innerHTML = `
          <div class="summary-pair">
            <span class="summary-label">Total distance</span>
            <span class="summary-value">${formatDistance(totalDistance)}</span>
          </div>
          <div class="summary-pair">
            <span class="summary-label">12-month distance</span>
            <span class="summary-value">${formatDistance(recentDistance)}</span>
          </div>
          <div class="summary-pair">
            <span class="summary-label">Rides logged</span>
            <span class="summary-value">${rides.length}</span>
          </div>
          <div class="summary-pair">
            <span class="summary-label">Runs logged</span>
            <span class="summary-value">${runs.length}</span>
          </div>
        `;

        const featured = [...rides]
          .sort((a, b) => b.distance - a.distance)
          .slice(0, 5);

        if (featured.length) {
          rideFeatureList.innerHTML = featured
            .map(
              (item) => `
                <li>
                  <span class="feature-title">${item.name}</span>
                  <span class="feature-meta">${formatDistance(item.distance)} · ${formatDate(item.startDate)}</span>
                </li>
              `
            )
            .join('');
        } else {
          rideFeatureList.innerHTML = '<li>No ride data yet—time to clip in.</li>';
        }
      };

      const drawHeatmap = (activities) => {
        if (!heatmapCanvas) return;
        const context = heatmapCanvas.getContext('2d');
        if (!context) return;

        const dpr = Math.min(window.devicePixelRatio || 1, 2);
        const width = heatmapCanvas.clientWidth || heatmapCanvas.width || 360;
        const height = heatmapCanvas.clientHeight || heatmapCanvas.height || 220;
        heatmapCanvas.width = width * dpr;
        heatmapCanvas.height = height * dpr;
        context.scale(dpr, dpr);

        context.clearRect(0, 0, width, height);
        context.fillStyle = '#fbf8f4';
        context.fillRect(0, 0, width, height);

        const points = activities
          .filter((item) => typeof item.lat === 'number' && typeof item.lon === 'number')
          .map((item) => ({
            x: ((item.lon + 180) / 360) * width,
            y: ((90 - item.lat) / 180) * height,
            weight: Math.min(Math.max(item.distance / 100000, 0.4), 2.2),
          }));

        points.forEach((point) => {
          const radius = 18 * point.weight;
          const gradient = context.createRadialGradient(point.x, point.y, 0, point.x, point.y, radius);
          gradient.addColorStop(0, 'rgba(193, 142, 87, 0.45)');
          gradient.addColorStop(1, 'rgba(193, 142, 87, 0)');
          context.fillStyle = gradient;
          context.beginPath();
          context.arc(point.x, point.y, radius, 0, Math.PI * 2);
          context.fill();
        });

        context.strokeStyle = 'rgba(193, 142, 87, 0.24)';
        context.lineWidth = 1;
        context.strokeRect(0.5, 0.5, width - 1, height - 1);
      };

      const loadActivities = async () => {
        try {
          const response = await fetch('assets/activities.json');
          if (!response.ok) throw new Error('Failed to load activities');
          const data = await response.json();

          const normalized = (data.activities || [])
            .map(normalizeActivity)
            .filter(Boolean);

          resetHover();
          markerGroup.clear();
          markerMeshes.length = 0;
          normalized.forEach(createMarker);

          renderSummary(normalized);
          drawHeatmap(normalized);
        } catch (error) {
          console.warn(error);
          rideSummary.textContent = 'Unable to reduce rides into view right now. Please refresh the page.';
          rideFeatureList.innerHTML = '<li>Heatmap paused—check your network connection.</li>';
        }
      };

      const animateGlobe = () => {
        requestAnimationFrame(animateGlobe);
        if (!userIsInteracting) {
          globeGroup.rotation.y += 0.00035;
        }
        controls.update();
        globeRenderer.render(globeScene, globeCamera);
      };

      resizeGlobe();
      window.addEventListener('resize', resizeGlobe);
      loadActivities();
      animateGlobe();

      const canvas = document.createElement('canvas');
      canvas.id = 'dna-helix';
      canvas.setAttribute('aria-hidden', 'true');
      document.body.appendChild(canvas);

      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
      renderer.setClearColor(0x000000, 0);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
      camera.position.set(0, 0, 16);
      camera.lookAt(0, 0, 0);

      const helixGroup = new THREE.Group();
      scene.add(helixGroup);

      const oliveColor = new THREE.Color('#636B2F');
      const baseOpacity = 0.5;

      const dotTexture = (() => {
        const size = 128;
        const texCanvas = document.createElement('canvas');
        texCanvas.width = texCanvas.height = size;
        const ctx = texCanvas.getContext('2d');
        const gradient = ctx.createRadialGradient(
          size / 2,
          size / 2,
          size * 0.1,
          size / 2,
          size / 2,
          size * 0.5
        );
        gradient.addColorStop(0, 'rgba(99,107,47,0.5)');
        gradient.addColorStop(1, 'rgba(99,107,47,0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, size, size);
        const texture = new THREE.CanvasTexture(texCanvas);
        texture.wrapS = texture.wrapT = THREE.ClampToEdgeWrapping;
        return texture;
      })();

      const segments = 900;
      const turns = 1.5;
      const helixHeight = 12.5;
      const helixRadius = 2.6;
      const rungInterval = 12;

      const strandPositions = [];
      const rungPositions = [];
      const pointPositions = [];
      const ambientPositions = [];
      const clusterPositions = [];
      const clusterLinkPositions = [];

      for (let i = 0; i <= segments; i++) {
        const progress = i / segments;
        const angle = progress * Math.PI * 2 * turns;
        const y = (progress - 0.5) * helixHeight;

        const baseX = Math.cos(angle) * helixRadius;
        const baseZ = Math.sin(angle) * helixRadius;
        const jitter = (Math.random() - 0.5) * 0.22;
        const x1 = baseX + jitter;
        const z1 = baseZ + jitter * 0.4;
        const x2 = -baseX + (Math.random() - 0.5) * 0.22;
        const z2 = -baseZ + (Math.random() - 0.5) * 0.22;

        pointPositions.push(x1, y, z1, x2, y, z2);

        if (i < segments) {
          const nextProgress = (i + 1) / segments;
          const nextAngle = nextProgress * Math.PI * 2 * turns;
          const nextY = (nextProgress - 0.5) * helixHeight;
          const nextBaseX = Math.cos(nextAngle) * helixRadius;
          const nextBaseZ = Math.sin(nextAngle) * helixRadius;
          const nextJitter = (Math.random() - 0.5) * 0.22;
          const nx1 = nextBaseX + nextJitter;
          const nz1 = nextBaseZ + nextJitter * 0.4;
          const nx2 = -nextBaseX + (Math.random() - 0.5) * 0.22;
          const nz2 = -nextBaseZ + (Math.random() - 0.5) * 0.22;

          strandPositions.push(x1, y, z1, nx1, nextY, nz1);
          strandPositions.push(x2, y, z2, nx2, nextY, nz2);
        }

        if (i % rungInterval === 0) {
          rungPositions.push(x1, y, z1, x2, y, z2);
        }

        if (i % 7 === 0) {
          const clusterSize = 16;
          for (let c = 0; c < clusterSize; c++) {
            const offsetRadius = helixRadius * (0.45 + Math.random() * 0.75);
            const offsetAngle = angle + (Math.random() - 0.5) * 1.1;
            const cx = Math.cos(offsetAngle) * offsetRadius + (Math.random() - 0.5) * 1.2;
            const cy = y + (Math.random() - 0.5) * 1.4;
            const cz = Math.sin(offsetAngle) * offsetRadius + (Math.random() - 0.5) * 1.2;

            clusterPositions.push(cx, cy, cz);
            clusterLinkPositions.push(cx, cy, cz, x1, y, z1);
          }
        }
      }

      const ambientCount = 2600;
      for (let i = 0; i < ambientCount; i++) {
        const spread = helixRadius * (0.9 + Math.random() * 1.1);
        const theta = Math.random() * Math.PI * 2 * turns;
        const y = (Math.random() - 0.5) * helixHeight * 1.1;
        const x = Math.cos(theta) * spread + (Math.random() - 0.5) * 0.7;
        const z = Math.sin(theta) * spread + (Math.random() - 0.5) * 0.7;
        ambientPositions.push(x, y, z);
      }

      const pointGeometry = new THREE.BufferGeometry();
      pointGeometry.setAttribute(
        'position',
        new THREE.Float32BufferAttribute(pointPositions, 3)
      );

      const strandGeometry = new THREE.BufferGeometry();
      strandGeometry.setAttribute(
        'position',
        new THREE.Float32BufferAttribute(strandPositions, 3)
      );

      const rungGeometry = new THREE.BufferGeometry();
      rungGeometry.setAttribute(
        'position',
        new THREE.Float32BufferAttribute(rungPositions, 3)
      );

      const ambientGeometry = new THREE.BufferGeometry();
      ambientGeometry.setAttribute(
        'position',
        new THREE.Float32BufferAttribute(ambientPositions, 3)
      );

      const clusterGeometry = new THREE.BufferGeometry();
      clusterGeometry.setAttribute(
        'position',
        new THREE.Float32BufferAttribute(clusterPositions, 3)
      );

      const clusterLinkGeometry = new THREE.BufferGeometry();
      clusterLinkGeometry.setAttribute(
        'position',
        new THREE.Float32BufferAttribute(clusterLinkPositions, 3)
      );

      const pointsMaterial = new THREE.PointsMaterial({
        map: dotTexture,
        alphaMap: dotTexture,
        color: oliveColor,
        size: 0.32,
        transparent: true,
        opacity: baseOpacity,
        blending: THREE.NormalBlending,
        depthWrite: false,
        sizeAttenuation: true,
      });

      const strandMaterial = new THREE.LineBasicMaterial({
        color: oliveColor,
        transparent: true,
        opacity: baseOpacity,
        blending: THREE.NormalBlending,
        depthWrite: false,
      });

      const rungMaterial = strandMaterial.clone();

      const ambientMaterial = new THREE.PointsMaterial({
        map: dotTexture,
        alphaMap: dotTexture,
        color: oliveColor,
        size: 0.22,
        transparent: true,
        opacity: baseOpacity,
        blending: THREE.NormalBlending,
        depthWrite: false,
        sizeAttenuation: true,
      });

      const clusterMaterial = new THREE.PointsMaterial({
        map: dotTexture,
        alphaMap: dotTexture,
        color: oliveColor,
        size: 0.28,
        transparent: true,
        opacity: baseOpacity,
        blending: THREE.NormalBlending,
        depthWrite: false,
        sizeAttenuation: true,
      });

      const clusterLinkMaterial = new THREE.LineBasicMaterial({
        color: oliveColor,
        transparent: true,
        opacity: baseOpacity,
        blending: THREE.NormalBlending,
        depthWrite: false,
      });

      helixGroup.add(new THREE.Points(pointGeometry, pointsMaterial));
      helixGroup.add(new THREE.LineSegments(strandGeometry, strandMaterial));
      helixGroup.add(new THREE.LineSegments(rungGeometry, rungMaterial));
      helixGroup.add(new THREE.Points(ambientGeometry, ambientMaterial));
      helixGroup.add(new THREE.Points(clusterGeometry, clusterMaterial));
      helixGroup.add(new THREE.LineSegments(clusterLinkGeometry, clusterLinkMaterial));

      helixGroup.scale.set(1.8, 0.45, 0.55);
      const baseRotation = new THREE.Euler(Math.PI / 5, Math.PI / 4, -Math.PI / 4);
      helixGroup.rotation.copy(baseRotation);

      const resizeRenderer = () => {
        const width = canvas.clientWidth;
        const height = canvas.clientHeight;
        if (!width || !height) return;
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(width, height, false);
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
      };

      window.addEventListener('resize', resizeRenderer);
      resizeRenderer();

      const maxScroll = () => document.body.scrollHeight - window.innerHeight;
      const baseRotationY = helixGroup.rotation.y;

      const updateScrollEffects = () => {
        const ratio = maxScroll() > 0 ? window.scrollY / maxScroll() : 0;
        const rotationRange = 0.45;
        helixGroup.rotation.y = baseRotationY + THREE.MathUtils.lerp(-rotationRange, rotationRange, ratio);
        const cameraTilt = THREE.MathUtils.lerp(-0.05, 0.04, ratio);
        camera.rotation.x = cameraTilt;
        canvas.style.opacity = (0.3 + (1 - ratio) * 0.15).toFixed(2);
      };

      window.addEventListener('scroll', updateScrollEffects, { passive: true });
      updateScrollEffects();

      const animate = () => {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
      };

      animate();
    </script>
  </body>
</html>
