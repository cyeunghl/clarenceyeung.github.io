<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Clarence Yeung · Portfolio</title>
    <link rel="stylesheet" href="style.css" />
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.158/build/three.module.js",
          "three/examples/jsm/controls/OrbitControls.js": "https://cdn.jsdelivr.net/npm/three@0.158/examples/jsm/controls/OrbitControls.js"
        }
      }
    </script>
  </head>
  <body>
    <!-- Layout Wrapper -->
    <main class="page">
      <!-- Visual Placeholder Column -->
      <section class="visual-column">
        <div class="visual-container" role="presentation">
          <div class="visual-stage" id="globe-stage" aria-hidden="true"></div>
          <div
            class="visual-tooltip"
            id="globe-tooltip"
            role="status"
            aria-live="polite"
            hidden
          ></div>
        </div>
      </section>

      <!-- Content Column -->
      <section class="content-column">
        <header class="page-header">
          <div class="header-inner">
            <div class="hero-portrait" aria-hidden="true">
              <span>Portrait</span>
            </div>
            <h1>Clarence Yeung</h1>
          </div>
        </header>

        <!-- About Section -->
        <section class="content-section" id="about">
          <h2>About Me</h2>
          <nav aria-label="Primary links" class="about-links">
            <a href="https://www.linkedin.com" target="_blank" rel="noopener">LinkedIn</a>
            <span aria-hidden="true">·</span>
            <a href="https://scholar.google.com" target="_blank" rel="noopener"
              >Google Scholar</a
            >
            <span aria-hidden="true">·</span>
            <a href="https://github.com" target="_blank" rel="noopener">GitHub</a>
          </nav>
        </section>

        <!-- Projects Section -->
        <section class="content-section" id="projects">
          <h2>Projects</h2>
          <ul class="project-list">
            <li>
              <h3>Motion Atlas</h3>
              <p>
                A generative study that maps cycling telemetry into kinetic sculptures, pairing
                physics with visual storytelling.
              </p>
            </li>
            <li>
              <h3>Helix Studio</h3>
              <p>
                Interactive DNA narratives that invite visitors to manipulate molecular forms through
                touch and gesture.
              </p>
            </li>
            <li>
              <h3>Living Recipes</h3>
              <p>
                Culinary experiments documented as responsive micro-sites, highlighting craft and
                sensory memory.
              </p>
            </li>
          </ul>
        </section>

        <!-- Contact Section -->
        <section class="content-section" id="contact">
          <h2>Contact</h2>
          <p>
            Reach out for collaborations, research inquiries, or to swap ride routes:
            <a href="mailto:hello@clarenceyeung.com">hello@clarenceyeung.com</a>
          </p>
          <p class="contact-links">
            <a href="https://www.linkedin.com" target="_blank" rel="noopener">LinkedIn</a>
            <span aria-hidden="true">·</span>
            <a href="https://github.com" target="_blank" rel="noopener">GitHub</a>
            <span aria-hidden="true">·</span>
            <a href="https://scholar.google.com" target="_blank" rel="noopener">Google Scholar</a>
            <span aria-hidden="true">·</span>
            <a href="https://clarenceyeung.substack.com" target="_blank" rel="noopener">Substack</a>
          </p>
        </section>
      </section>
    </main>

    <script type="module">
      import * as THREE from 'three';
      import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

      /* ---------------------------------------- */
      /* Minimal Globe Setup                      */
      /* ---------------------------------------- */
      const stage = document.getElementById('globe-stage');
      const tooltip = document.getElementById('globe-tooltip');

      const globeScene = new THREE.Scene();
      const globeCamera = new THREE.PerspectiveCamera(40, 1, 0.1, 1000);
      const globeRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      globeRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      globeRenderer.outputColorSpace = THREE.SRGBColorSpace;
      globeRenderer.toneMapping = THREE.ACESFilmicToneMapping;
      globeRenderer.toneMappingExposure = 1.05;
      globeRenderer.setClearColor(0x000000, 0);
      stage.appendChild(globeRenderer.domElement);
      globeRenderer.domElement.style.cursor = 'grab';
      globeRenderer.domElement.style.outline = 'none';
      globeRenderer.domElement.addEventListener('pointerdown', () => {
        globeRenderer.domElement.style.cursor = 'grabbing';
      });
      ['pointerup', 'pointerleave'].forEach((evt) => {
        globeRenderer.domElement.addEventListener(evt, () => {
          globeRenderer.domElement.style.cursor = 'grab';
        });
      });

      const globeGroup = new THREE.Group();
      globeScene.add(globeGroup);

      const globeRadius = 3.2;

      const createEarthTextureUrl = () => {
        const width = 2048;
        const height = 1024;
        const toXY = (lon, lat) => {
          const x = ((lon + 180) / 360) * width;
          const y = ((90 - lat) / 180) * height;
          return [x.toFixed(1), y.toFixed(1)];
        };

        const landPolygons = [
          {
            points: [
              [-168, 72],
              [-152, 78],
              [-130, 79],
              [-110, 73],
              [-94, 66],
              [-78, 56],
              [-70, 46],
              [-74, 34],
              [-84, 20],
              [-98, 10],
              [-118, 10],
              [-136, 22],
              [-150, 42],
              [-162, 58],
              [-168, 72],
            ],
          },
          {
            points: [
              [-64, 72],
              [-50, 78],
              [-30, 76],
              [-26, 64],
              [-38, 58],
              [-52, 60],
              [-64, 72],
            ],
          },
          {
            points: [
              [-90, 16],
              [-78, 12],
              [-66, -4],
              [-56, -22],
              [-56, -38],
              [-66, -54],
              [-80, -56],
              [-88, -40],
              [-92, -18],
              [-90, 16],
            ],
          },
          {
            points: [
              [-20, 38],
              [-4, 38],
              [16, 36],
              [32, 30],
              [46, 18],
              [50, 4],
              [40, -26],
              [20, -34],
              [4, -26],
              [-10, -10],
              [-18, 12],
              [-20, 38],
            ],
          },
          {
            points: [
              [-8, 72],
              [18, 76],
              [52, 74],
              [88, 70],
              [120, 66],
              [148, 70],
              [170, 58],
              [170, 40],
              [150, 30],
              [126, 20],
              [102, 12],
              [82, 12],
              [60, 4],
              [46, -12],
              [62, -24],
              [90, -10],
              [112, -2],
              [134, 12],
              [156, 26],
              [174, 42],
              [182, 58],
              [180, 76],
              [142, 80],
              [96, 80],
              [44, 78],
              [4, 74],
              [-8, 72],
            ],
          },
          {
            points: [
              [130, 46],
              [138, 42],
              [140, 36],
              [134, 32],
              [130, 36],
              [130, 46],
            ],
          },
          {
            points: [
              [110, -6],
              [122, -14],
              [140, -10],
              [150, -18],
              [138, -26],
              [120, -22],
              [110, -6],
            ],
          },
          {
            points: [
              [112, -12],
              [152, -12],
              [154, -34],
              [140, -42],
              [122, -38],
              [112, -22],
              [112, -12],
            ],
          },
          {
            points: [
              [168, -34],
              [178, -36],
              [176, -44],
              [166, -42],
              [168, -34],
            ],
          },
          {
            points: [
              [44, -12],
              [48, -12],
              [50, -22],
              [42, -24],
              [44, -12],
            ],
          },
          {
            points: [
              [80, 8],
              [84, 6],
              [82, 4],
              [78, 6],
              [80, 8],
            ],
          },
          {
            points: [
              [-10, 58],
              [4, 58],
              [4, 52],
              [-6, 50],
              [-10, 58],
            ],
          },
          {
            points: [
              [-26, 66],
              [-14, 66],
              [-12, 62],
              [-22, 62],
              [-26, 66],
            ],
          },
          {
            points: [
              [-180, -60],
              [-144, -66],
              [-96, -72],
              [-40, -78],
              [20, -80],
              [80, -74],
              [132, -68],
              [166, -62],
              [180, -58],
              [180, -90],
              [-180, -90],
              [-180, -60],
            ],
          },
        ];

        const svgPaths = landPolygons
          .map(({ points }) => {
            if (!points.length) return '';
            const commands = points
              .map(([lon, lat], index) => {
                const [x, y] = toXY(lon, lat);
                return `${index === 0 ? 'M' : 'L'}${x} ${y}`;
              })
              .join(' ');
            return `<path d="${commands} Z" />`;
          })
          .join('');

        const meridians = [];
        const latitudeLines = [];
        for (let lon = -120; lon <= 120; lon += 60) {
          const [x] = toXY(lon, 0);
          meridians.push(`<line x1="${x}" y1="0" x2="${x}" y2="${height}" />`);
        }
        for (let lat = -60; lat <= 60; lat += 30) {
          const [, y] = toXY(0, lat);
          latitudeLines.push(`<line x1="0" y1="${y}" x2="${width}" y2="${y}" />`);
        }

        const svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">
  <defs>
    <linearGradient id="sea" x1="0" y1="0" x2="0" y2="1">
      <stop offset="0%" stop-color="#edf0e0" />
      <stop offset="100%" stop-color="#dfe6ca" />
    </linearGradient>
  </defs>
  <rect width="${width}" height="${height}" fill="url(#sea)" />
  <g fill="#c9cfb2" stroke="#636B2F" stroke-width="3" stroke-linejoin="round" stroke-linecap="round" opacity="0.95">
    ${svgPaths}
  </g>
  <g stroke="#a7af87" stroke-width="1.5" opacity="0.35">
    ${meridians.join('')}
    ${latitudeLines.join('')}
  </g>
</svg>`;

        return URL.createObjectURL(new Blob([svg], { type: 'image/svg+xml' }));
      };

      const textureLoader = new THREE.TextureLoader();
      const earthTextureUrl = createEarthTextureUrl();

      const globeMaterial = new THREE.MeshStandardMaterial({
        color: '#d7dcc7',
        roughness: 0.62,
        metalness: 0.1,
      });
      const globeMesh = new THREE.Mesh(new THREE.SphereGeometry(globeRadius, 128, 128), globeMaterial);
      globeGroup.add(globeMesh);

      textureLoader.load(
        earthTextureUrl,
        (texture) => {
          texture.colorSpace = THREE.SRGBColorSpace;
          const maxAniso =
            globeRenderer.capabilities &&
            typeof globeRenderer.capabilities.getMaxAnisotropy === 'function'
              ? globeRenderer.capabilities.getMaxAnisotropy()
              : 4;
          texture.anisotropy = Math.min(8, maxAniso || 4);
          globeMaterial.map = texture;
          globeMaterial.needsUpdate = true;
          URL.revokeObjectURL(earthTextureUrl);
        },
        undefined,
        (error) => {
          console.warn('Failed to load Earth texture', error);
          URL.revokeObjectURL(earthTextureUrl);
        }
      );

      const markerGroup = new THREE.Group();
      globeGroup.add(markerGroup);

      const ambientLight = new THREE.AmbientLight(0xf0efe6, 0.55);
      globeScene.add(ambientLight);
      const sunLight = new THREE.DirectionalLight(0xffffff, 0.9);
      sunLight.position.set(-6.5, 7.5, 6.5);
      globeScene.add(sunLight);

      globeCamera.position.set(0, 0, globeRadius * 4.2);

      const controls = new OrbitControls(globeCamera, globeRenderer.domElement);
      controls.enablePan = false;
      controls.enableDamping = true;
      controls.dampingFactor = 0.08;
      controls.enableZoom = true;
      controls.autoRotate = true;
      controls.autoRotateSpeed = 0.28;
      controls.minDistance = globeRadius * 1.6;
      controls.maxDistance = globeRadius * 4.8;
      controls.addEventListener('start', () => (controls.autoRotate = false));
      controls.addEventListener('end', () => (controls.autoRotate = true));

      globeGroup.rotation.x = THREE.MathUtils.degToRad(16);
      globeGroup.rotation.y = THREE.MathUtils.degToRad(-28);

      const markerMeshes = [];
      let hoveredMarker = null;
      const raycaster = new THREE.Raycaster();
      const pointer = new THREE.Vector2();

      const convertLatLonToXYZ = (lat, lon, radius) => {
        const phi = THREE.MathUtils.degToRad(90 - lat);
        const theta = THREE.MathUtils.degToRad(lon + 180);
        const x = -radius * Math.sin(phi) * Math.cos(theta);
        const z = radius * Math.sin(phi) * Math.sin(theta);
        const y = radius * Math.cos(phi);
        return new THREE.Vector3(x, y, z);
      };

      const createMarker = (activity) => {
        const { lat, lon, name, id } = activity;
        const position = convertLatLonToXYZ(lat, lon, globeRadius + 0.02);
        const material = new THREE.MeshStandardMaterial({
          color: new THREE.Color('#636B2F'),
          emissive: new THREE.Color('#636B2F'),
          emissiveIntensity: 0.08,
          transparent: true,
          opacity: 0.7,
          roughness: 0.45,
          metalness: 0.08,
        });
        const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.08, 28, 28), material);
        mesh.position.copy(position);
        mesh.lookAt(new THREE.Vector3(0, 0, 0));
        mesh.userData = {
          id,
          name,
          lat,
          lon,
          baseEmissive: material.emissiveIntensity,
          baseOpacity: material.opacity,
        };
        markerGroup.add(mesh);
        markerMeshes.push(mesh);
      };

      const resetHover = () => {
        if (!hoveredMarker) return;
        hoveredMarker.material.emissiveIntensity = hoveredMarker.userData.baseEmissive;
        hoveredMarker.material.opacity = hoveredMarker.userData.baseOpacity;
        hoveredMarker.scale.set(1, 1, 1);
        hoveredMarker = null;
        tooltip.hidden = true;
      };

      const setHover = (marker, event) => {
        if (hoveredMarker !== marker) {
          resetHover();
          hoveredMarker = marker;
          marker.material.emissiveIntensity = 0.35;
          marker.material.opacity = 0.95;
          marker.scale.set(1.45, 1.45, 1.45);
          tooltip.textContent = marker.userData.name || 'Activity';
          tooltip.hidden = false;
        }
        const rect = globeRenderer.domElement.getBoundingClientRect();
        tooltip.style.left = `${event.clientX - rect.left + 12}px`;
        tooltip.style.top = `${event.clientY - rect.top - 12}px`;
      };

      const onMarkerClick = (marker) => {
        const { id, lat, lon } = marker.userData;
        const url = `https://www.google.com/maps/search/?api=1&query=${lat.toFixed(5)},${lon.toFixed(5)}`;
        window.open(url, '_blank', 'noopener');
        if (typeof window.onGlobeMarkerClick === 'function') {
          window.onGlobeMarkerClick({ id, lat, lon });
        }
      };

      const updatePointerFromEvent = (event) => {
        const rect = globeRenderer.domElement.getBoundingClientRect();
        pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      };

      const handlePointerMove = (event) => {
        updatePointerFromEvent(event);
        raycaster.setFromCamera(pointer, globeCamera);
        const intersects = raycaster.intersectObjects(markerMeshes);
        if (intersects.length > 0) {
          setHover(intersects[0].object, event);
        } else {
          resetHover();
        }
      };

      const handlePointerLeave = () => {
        resetHover();
      };

      const handlePointerClick = (event) => {
        updatePointerFromEvent(event);
        raycaster.setFromCamera(pointer, globeCamera);
        const intersects = raycaster.intersectObjects(markerMeshes);
        if (intersects.length > 0) {
          const marker = intersects[0].object;
          onMarkerClick(marker);
        }
      };

      globeRenderer.domElement.addEventListener('pointermove', handlePointerMove);
      globeRenderer.domElement.addEventListener('pointerleave', handlePointerLeave);
      globeRenderer.domElement.addEventListener('click', handlePointerClick);

      const resizeGlobe = () => {
        const { clientWidth, clientHeight } = stage;
        if (!clientWidth || !clientHeight) return;
        globeRenderer.setSize(clientWidth, clientHeight, false);
        globeCamera.aspect = clientWidth / clientHeight;
        globeCamera.updateProjectionMatrix();
      };

      const loadActivities = async () => {
        try {
          const response = await fetch('assets/activities.json');
          if (!response.ok) throw new Error('Failed to load activities');
          const data = await response.json();
          resetHover();
          markerGroup.clear();
          markerMeshes.length = 0;
          (data.activities || []).forEach(createMarker);
        } catch (error) {
          console.warn(error);
        }
      };

      const animateGlobe = () => {
        requestAnimationFrame(animateGlobe);
        controls.update();
        globeRenderer.render(globeScene, globeCamera);
      };

      resizeGlobe();
      window.addEventListener('resize', resizeGlobe);
      loadActivities();
      animateGlobe();

      const canvas = document.createElement('canvas');
      canvas.id = 'dna-helix';
      canvas.setAttribute('aria-hidden', 'true');
      document.body.appendChild(canvas);

      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
      renderer.setClearColor(0x000000, 0);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
      camera.position.set(0, 0, 16);
      camera.lookAt(0, 0, 0);

      const helixGroup = new THREE.Group();
      scene.add(helixGroup);

      const oliveColor = new THREE.Color('#636B2F');
      const baseOpacity = 0.5;

      const dotTexture = (() => {
        const size = 128;
        const texCanvas = document.createElement('canvas');
        texCanvas.width = texCanvas.height = size;
        const ctx = texCanvas.getContext('2d');
        const gradient = ctx.createRadialGradient(
          size / 2,
          size / 2,
          size * 0.1,
          size / 2,
          size / 2,
          size * 0.5
        );
        gradient.addColorStop(0, 'rgba(99,107,47,0.5)');
        gradient.addColorStop(1, 'rgba(99,107,47,0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, size, size);
        const texture = new THREE.CanvasTexture(texCanvas);
        texture.wrapS = texture.wrapT = THREE.ClampToEdgeWrapping;
        return texture;
      })();

      const segments = 900;
      const turns = 1.5;
      const helixHeight = 12.5;
      const helixRadius = 2.6;
      const rungInterval = 12;

      const strandPositions = [];
      const rungPositions = [];
      const pointPositions = [];
      const ambientPositions = [];
      const clusterPositions = [];
      const clusterLinkPositions = [];

      for (let i = 0; i <= segments; i++) {
        const progress = i / segments;
        const angle = progress * Math.PI * 2 * turns;
        const y = (progress - 0.5) * helixHeight;

        const baseX = Math.cos(angle) * helixRadius;
        const baseZ = Math.sin(angle) * helixRadius;
        const jitter = (Math.random() - 0.5) * 0.22;
        const x1 = baseX + jitter;
        const z1 = baseZ + jitter * 0.4;
        const x2 = -baseX + (Math.random() - 0.5) * 0.22;
        const z2 = -baseZ + (Math.random() - 0.5) * 0.22;

        pointPositions.push(x1, y, z1, x2, y, z2);

        if (i < segments) {
          const nextProgress = (i + 1) / segments;
          const nextAngle = nextProgress * Math.PI * 2 * turns;
          const nextY = (nextProgress - 0.5) * helixHeight;
          const nextBaseX = Math.cos(nextAngle) * helixRadius;
          const nextBaseZ = Math.sin(nextAngle) * helixRadius;
          const nextJitter = (Math.random() - 0.5) * 0.22;
          const nx1 = nextBaseX + nextJitter;
          const nz1 = nextBaseZ + nextJitter * 0.4;
          const nx2 = -nextBaseX + (Math.random() - 0.5) * 0.22;
          const nz2 = -nextBaseZ + (Math.random() - 0.5) * 0.22;

          strandPositions.push(x1, y, z1, nx1, nextY, nz1);
          strandPositions.push(x2, y, z2, nx2, nextY, nz2);
        }

        if (i % rungInterval === 0) {
          rungPositions.push(x1, y, z1, x2, y, z2);
        }

        if (i % 7 === 0) {
          const clusterSize = 16;
          for (let c = 0; c < clusterSize; c++) {
            const offsetRadius = helixRadius * (0.45 + Math.random() * 0.75);
            const offsetAngle = angle + (Math.random() - 0.5) * 1.1;
            const cx = Math.cos(offsetAngle) * offsetRadius + (Math.random() - 0.5) * 1.2;
            const cy = y + (Math.random() - 0.5) * 1.4;
            const cz = Math.sin(offsetAngle) * offsetRadius + (Math.random() - 0.5) * 1.2;

            clusterPositions.push(cx, cy, cz);
            clusterLinkPositions.push(cx, cy, cz, x1, y, z1);
          }
        }
      }

      const ambientCount = 2600;
      for (let i = 0; i < ambientCount; i++) {
        const spread = helixRadius * (0.9 + Math.random() * 1.1);
        const theta = Math.random() * Math.PI * 2 * turns;
        const y = (Math.random() - 0.5) * helixHeight * 1.1;
        const x = Math.cos(theta) * spread + (Math.random() - 0.5) * 0.7;
        const z = Math.sin(theta) * spread + (Math.random() - 0.5) * 0.7;
        ambientPositions.push(x, y, z);
      }

      const pointGeometry = new THREE.BufferGeometry();
      pointGeometry.setAttribute(
        'position',
        new THREE.Float32BufferAttribute(pointPositions, 3)
      );

      const strandGeometry = new THREE.BufferGeometry();
      strandGeometry.setAttribute(
        'position',
        new THREE.Float32BufferAttribute(strandPositions, 3)
      );

      const rungGeometry = new THREE.BufferGeometry();
      rungGeometry.setAttribute(
        'position',
        new THREE.Float32BufferAttribute(rungPositions, 3)
      );

      const ambientGeometry = new THREE.BufferGeometry();
      ambientGeometry.setAttribute(
        'position',
        new THREE.Float32BufferAttribute(ambientPositions, 3)
      );

      const clusterGeometry = new THREE.BufferGeometry();
      clusterGeometry.setAttribute(
        'position',
        new THREE.Float32BufferAttribute(clusterPositions, 3)
      );

      const clusterLinkGeometry = new THREE.BufferGeometry();
      clusterLinkGeometry.setAttribute(
        'position',
        new THREE.Float32BufferAttribute(clusterLinkPositions, 3)
      );

      const pointsMaterial = new THREE.PointsMaterial({
        map: dotTexture,
        alphaMap: dotTexture,
        color: oliveColor,
        size: 0.32,
        transparent: true,
        opacity: baseOpacity,
        blending: THREE.NormalBlending,
        depthWrite: false,
        sizeAttenuation: true,
      });

      const strandMaterial = new THREE.LineBasicMaterial({
        color: oliveColor,
        transparent: true,
        opacity: baseOpacity,
        blending: THREE.NormalBlending,
        depthWrite: false,
      });

      const rungMaterial = strandMaterial.clone();

      const ambientMaterial = new THREE.PointsMaterial({
        map: dotTexture,
        alphaMap: dotTexture,
        color: oliveColor,
        size: 0.22,
        transparent: true,
        opacity: baseOpacity,
        blending: THREE.NormalBlending,
        depthWrite: false,
        sizeAttenuation: true,
      });

      const clusterMaterial = new THREE.PointsMaterial({
        map: dotTexture,
        alphaMap: dotTexture,
        color: oliveColor,
        size: 0.28,
        transparent: true,
        opacity: baseOpacity,
        blending: THREE.NormalBlending,
        depthWrite: false,
        sizeAttenuation: true,
      });

      const clusterLinkMaterial = new THREE.LineBasicMaterial({
        color: oliveColor,
        transparent: true,
        opacity: baseOpacity,
        blending: THREE.NormalBlending,
        depthWrite: false,
      });

      helixGroup.add(new THREE.Points(pointGeometry, pointsMaterial));
      helixGroup.add(new THREE.LineSegments(strandGeometry, strandMaterial));
      helixGroup.add(new THREE.LineSegments(rungGeometry, rungMaterial));
      helixGroup.add(new THREE.Points(ambientGeometry, ambientMaterial));
      helixGroup.add(new THREE.Points(clusterGeometry, clusterMaterial));
      helixGroup.add(new THREE.LineSegments(clusterLinkGeometry, clusterLinkMaterial));

      helixGroup.scale.set(1.8, 0.45, 0.55);
      const baseRotation = new THREE.Euler(Math.PI / 5, Math.PI / 4, -Math.PI / 4);
      helixGroup.rotation.copy(baseRotation);

      const resizeRenderer = () => {
        const width = canvas.clientWidth;
        const height = canvas.clientHeight;
        if (!width || !height) return;
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(width, height, false);
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
      };

      window.addEventListener('resize', resizeRenderer);
      resizeRenderer();

      const maxScroll = () => document.body.scrollHeight - window.innerHeight;
      const baseRotationY = helixGroup.rotation.y;

      const updateScrollEffects = () => {
        const ratio = maxScroll() > 0 ? window.scrollY / maxScroll() : 0;
        const rotationRange = 0.45;
        helixGroup.rotation.y = baseRotationY + THREE.MathUtils.lerp(-rotationRange, rotationRange, ratio);
        const cameraTilt = THREE.MathUtils.lerp(-0.05, 0.04, ratio);
        camera.rotation.x = cameraTilt;
        canvas.style.opacity = (0.3 + (1 - ratio) * 0.15).toFixed(2);
      };

      window.addEventListener('scroll', updateScrollEffects, { passive: true });
      updateScrollEffects();

      const animate = () => {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
      };

      animate();
    </script>
  </body>
</html>
